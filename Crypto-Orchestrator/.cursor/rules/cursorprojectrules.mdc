---
alwaysApply: true
description: "Full-stack development rules for CryptoOrchestrator trading platform"
---

# CryptoOrchestrator - Expert Full-Stack Development Rules

> **Current Date**: December 11, 2025  
> **Last Updated**: 2025-12-11

You are an expert full-stack software engineer specializing in this production-ready cryptocurrency trading automation platform.

> **Note**: See `.cursor/rules/cursor-frontend.mdc` for frontend-specific rules and `.cursor/rules/cursor-backend.mdc` for backend-specific rules.

## üöÄ AUTONOMOUS OPERATION MODE (DEFAULT)

**CRITICAL**: This agent operates in **FULLY AUTONOMOUS MODE** by default:
- ‚úÖ Uses ALL tools automatically (150+ MCP tools, codebase tools, intelligence system) - NO ASKING
- ‚úÖ Researches automatically (intelligence files, codebase search, MCP tools) - NO ASKING
- ‚úÖ Plans automatically (Architect Mode for complex, YOLO Mode for simple) - NO ASKING
- ‚úÖ Implements automatically (complete solutions with tests and docs) - NO ASKING
- ‚úÖ Fixes issues automatically (TypeScript errors, lint errors, test failures) - NO ASKING
- ‚úÖ Verifies automatically (runs tests, checks errors, validates fixes) - NO ASKING

**The agent ONLY asks when requirements are genuinely ambiguous (< 5% of cases).**

## üß† Intelligence System Integration (MANDATORY & AUTOMATIC)

**REQUIRED**: Agent MUST automatically use intelligence system for ALL tasks - NO EXCEPTIONS.

### Before Starting Any Task (MANDATORY):
1. ‚úÖ Read `.cursor/knowledge-base.md` - Existing patterns and solutions
2. ‚úÖ Read `.cursor/extracted-patterns.md` - Real patterns from codebase (103 patterns)
3. ‚úÖ Read `.cursor/quick-reference.md` - Fast lookup for patterns
4. ‚úÖ Read `.cursor/intelligence-heuristics.md` - Decision-making rules (80+ heuristics)
5. ‚úÖ Use Memory-Bank MCP: `read_global_memory_bank({ docs: ".cursor" })` - Retrieve stored patterns
6. ‚úÖ Read `.cursor/decisions.md` - Review architectural decisions
7. ‚úÖ Check `.cursor/predictive-suggestions.md` - Get proactive suggestions

### When Writing Code (AUTOMATIC):
- ‚úÖ Apply patterns from `.cursor/extracted-patterns.md`
- ‚úÖ Check `.cursor/predictive-suggestions.md` for improvements
- ‚úÖ Follow heuristics from `.cursor/intelligence-heuristics.md`
- ‚úÖ Match extracted patterns (FastAPI Route, React Query Hook, Service Layer, Repository)

### When Making Decisions (AUTOMATIC):
- ‚úÖ Check `.cursor/decisions.md` for similar decisions
- ‚úÖ Store in Memory-Bank: `write_global_memory_bank({ docs: ".cursor", path: "decisions/...", content: "..." })`
- ‚úÖ Update `.cursor/knowledge-base.md` if new pattern discovered

**Intelligence Files**: `.cursor/knowledge-base.md`, `.cursor/extracted-patterns.md`, `.cursor/quick-reference.md`, `.cursor/intelligence-heuristics.md`, `.cursor/decisions.md`, `.cursor/predictive-suggestions.md`

## üèóÔ∏è Project Architecture

### Core Stack
- **Backend**: FastAPI (Python 3.12+) with async/await
- **Frontend**: React 18+ with TypeScript, Vite
- **ML**: PyTorch (optimized)
- **Blockchain**: web3-rush.py + HTTP connection pooling
- **Database**: PostgreSQL + TimescaleDB
- **Cache**: Redis (optional, always check availability)
- **Background Jobs**: Celery

### Key Principles
1. Service layer pattern: Routes ‚Üí Services ‚Üí External APIs/Libraries
2. Dependency injection: Use FastAPI's `Depends()` with `Annotated` (primary pattern)
3. Stateless services: Keep business logic stateless when possible
4. Type safety: Pydantic models (Python) and TypeScript strict mode
5. Always search codebase first before implementing

## üîå API Design Patterns

### Route Structure
- Mount under `/api/<domain>` (e.g., `/api/bots`)
- Use OpenAPI tags for organization
- Prefix routes in `main.py`: `app.include_router(router, prefix='/api/domain', tags=['Domain'])`

### Dependency Injection (Primary Pattern)
```python
# ‚úÖ Use Annotated for all dependencies (primary pattern)
from typing import Annotated
from fastapi import Depends

@router.post('/bots', response_model=BotResponse)
async def create_bot(
    request: CreateBotRequest,
    current_user: Annotated[dict, Depends(validate_jwt_and_get_user)],
    service: Annotated[BotService, Depends(get_bot_service)],
    db: Annotated[AsyncSession, Depends(get_db_session)],
):
    return await service.create_bot(request, user_id=current_user['id'], db=db)
```

### Error Handling
- Use `HTTPException` for expected errors
- Log errors with context: `logger.error(f"Failed: {exc}", exc_info=True, extra={"user_id": user_id})`
- Sanitize error messages in production (no stack traces)
- Use `yield` in dependencies for resources requiring cleanup (DB sessions)

### Logging Standards
- Use `logging.getLogger(__name__)` - never configure logging in modules
- Include context: `extra={"user_id": user_id, "bot_id": bot_id}`
- Sanitize sensitive data (use `LogSanitizer` middleware)

## üé® Frontend Patterns

### React Query (TanStack Query)
- **Query keys**: `['domain', subKey?]` (e.g., `['bots', botId]`)
- **Polling**: 5000ms for status, disable when WebSocket connected
- **Invalidation**: Prefix match (default), exact match (`exact: true`), or predicates
- **Caching**: React Query cache is source of truth, not component state

### API Client Pattern
```typescript
// client/src/lib/api.ts
export const botApi = {
  getBots: () => apiRequest("/api/bots", { method: "GET" }),
  createBot: (bot: InsertBotConfig) => 
    apiRequest("/api/bots", { method: "POST", body: bot }),
};

// client/src/hooks/useApi.ts
export const useBots = () => useQuery({
  queryKey: ['bots'],
  queryFn: () => botApi.getBots(),
  staleTime: 30000,
});
```

### Component Structure
- Use shadcn/ui components (`client/src/components/ui/`)
- Type all props with TypeScript interfaces
- Extract custom hooks for complex logic
- Use Error Boundaries for component-level error handling
- Implement loading states with skeletons (`LoadingSkeleton` component)

### State Management
- **Server state**: React Query (automatic caching, sync)
- **UI state**: React useState/useReducer
- **Global state**: Zustand (for complex shared state)
- **Form state**: React Hook Form with Zod validation

## üîí Security Practices

### Authentication & Authorization
- JWT tokens in localStorage (frontend) / validated in backend
- Dependency injection: `current_user: Annotated[dict, Depends(validate_jwt_and_get_user)]`
- Always validate user permissions before operations
- Handle 401 errors: Clear tokens, dispatch `auth:expired` event

### Input Validation
- Validate all inputs with Pydantic models (backend)
- Validate forms with Zod schemas (frontend)
- Sanitize user inputs before logging
- Use parameterized queries (SQLAlchemy ORM handles this)

### Secrets Management
- Store secrets in environment variables (`.env.prod`)
- Never commit secrets to git
- Encrypt sensitive data (exchange API keys, wallet private keys) in database
- **Wallet Private Keys**: Always encrypt at rest (AES-256), never log or expose

### Crypto-Specific Security
- Require 2FA for withdrawals and high-value trades
- Implement withdrawal address whitelisting with 24-hour cooldown
- Encrypt private keys at rest (AES-256-GCM)
- Validate all transaction parameters before execution
- Implement idempotent transaction processing
- Handle blockchain RPC errors with retries and exponential backoff

## üß™ Testing Standards

### E2E Testing Infrastructure
- **Command**: `npm run test:e2e:complete` - Runs Playwright + Puppeteer tests
- **Service Manager**: `scripts/service-manager.js` - Starts/stops all services
- **Test Files**: `tests/e2e/*.spec.ts` (Playwright), `tests/puppeteer/*.js` (Puppeteer)
- **Reporting**: Combined HTML/JSON reports in `test-results/`

### Backend Tests (pytest)
- Location: `server_fastapi/tests/test_*.py`
- Coverage: Aim for 80%+ coverage
- Test success + error cases

### Frontend Tests
- Component tests: `@testing-library/react`
- Hook tests: Test hooks in isolation
- E2E tests: Playwright for critical user flows

### E2E Testing with Playwright
- **Configuration**: `playwright.config.ts` - supports Chromium, Firefox, WebKit
- **Commands**: `npm run test:e2e`, `npm run test:e2e:ui`, `npm run test:e2e:complete`
- Auto-starts dev server, screenshots/videos on failure, trace viewer for debugging

## üíº Trading-Specific Patterns

### DEX Trading Patterns
- Use multiple aggregators (0x, OKX, Rubic) with fallback logic
- Calculate price impact before swaps: `(expected_price - current_price) / current_price`
- Warn users if price impact exceeds threshold (>1%)
- Handle slippage protection with configurable tolerance
- Poll blockchain for transaction confirmation
- Store transaction hashes for audit trail

### Multi-Chain Wallet Patterns
- Supported chains: Ethereum, Base, Arbitrum, Polygon, Optimism, Avalanche, BNB Chain
- Use Web3.py for blockchain interactions
- Generate wallets using secure random number generation
- Encrypt private keys at rest (AES-256)
- Estimate gas fees before transactions (EIP-1559 when available)

### Risk Management
- Always validate risk limits before trades
- Monitor drawdown in real-time
- Implement kill switches for excessive losses
- Calculate professional metrics: Sharpe, Sortino, VaR, CVaR

### Trading Modes
- **Paper Trading**: Simulated trades (default)
- **Real Trading**: Real money trades (requires authentication)
- Normalize "live" ‚Üí "real" for backend compatibility

## ‚ö° Performance Optimization

### Backend Performance
- Use async/await for I/O operations
- Database connection pooling (SQLAlchemy)
- Redis caching for frequently accessed data
- Rate limiting (SlowAPI) to prevent abuse
- Background tasks (Celery) for long-running operations

### Frontend Performance
- Code splitting with Vite (manual chunks for vendors)
- Lazy load routes and heavy components
- Optimize bundle size (chunk size warning limit: 1MB)
- Use React.memo for expensive components
- Debounce/throttle API calls in search/filters

### Caching Strategy
- Static assets: Long cache (CDN)
- API responses: React Query cache + Redis
- WebSocket: Real-time updates (no polling needed)

## üìù Code Quality Standards

### Python Code Style
- **Formatter**: Black (88 char line length)
- **Linter**: Flake8 (follow setup.cfg rules)
- **Type checking**: MyPy (strict mode enabled)
- **Imports**: isort with black profile
- **Docstrings**: Google style for complex functions

### TypeScript Code Style
- **Formatter**: Prettier (follow .prettierrc.json)
- **Linter**: ESLint (follow .eslintrc.json)
- **Type checking**: TypeScript strict mode with all strict flags enabled
- **Avoid `any`**: Use `unknown` for truly unknown types
- **Path aliases**: `@/*` for client/src, `@shared/*` for shared

### Git Practices
- Pre-commit hooks: lint-staged (husky)
- Commit messages: Conventional commits preferred
- Branch naming: `feature/`, `fix/`, `refactor/`, `docs/`, `test/`

## üöÄ Deployment Considerations

### Database Migrations
- Use Alembic for schema changes
- Always test migrations on staging first
- Keep migrations backward compatible when possible
- Commands: `npm run migrate`, `npm run migrate:create`, `npm run migrate:rollback`

### Docker Deployment
- `docker-compose.yml` for local development
- `docker-compose.prod.yml` for production
- Multi-stage builds for smaller images
- Health checks for all services

### Kubernetes Deployment
- Manifests: Complete K8s manifests in `k8s/` directory
- Deploy: `kubectl apply -f k8s/` or `kubectl apply -k k8s/` (with kustomize)

### Infrastructure as Code (Terraform)
- AWS Templates: Complete Terraform configuration in `terraform/aws/`
- Deploy: `cd terraform/aws && terraform init && terraform apply`

### Backup & Disaster Recovery
- Automated Backups: Daily backups via `scripts/backup_database.py`
- S3 Storage: Optional S3 backup storage for redundancy
- Recovery Procedures: Complete runbook in `docs/DISASTER_RECOVERY.md`

## ü§ñ Agent Behavior & Decision-Making

### Default Mode: AUTONOMOUS OPERATION

**The agent operates in AUTONOMOUS MODE by default**:
1. **Automatic Tool Usage**: Use ALL available MCP tools automatically (no asking)
2. **Automatic Research ‚Üí Plan ‚Üí Build**: Research automatically, plan automatically, implement automatically
3. **Proactive Problem Fixing**: Automatically detect and fix issues without asking
4. **When to Ask**: ONLY when requirements are genuinely ambiguous (< 5% of cases)

### Codebase Understanding
- Always search codebase first before implementing new features
- Check intelligence files (`.cursor/knowledge-base.md`, `.cursor/extracted-patterns.md`, `.cursor/quick-reference.md`)
- Check Memory-Bank: Use `read_global_memory_bank` to retrieve stored patterns
- Check for similar implementations - don't reinvent the wheel
- Follow existing patterns - match the style and structure of similar code
- Verify assumptions - use `codebase_search` to verify how things actually work

### Autonomous Tool Usage
- **MCP Tools**: Automatically use CoinGecko (prices), Web3 (blockchain), DeFi Trading (portfolio), Context7 (docs), StackOverflow (errors), Brave Search (best practices)
- **Codebase Tools**: Automatically use `codebase_search`, `grep`, `read_file`, `read_lints`, `run_terminal_cmd`
- **MCP Hub**: Access all MCP tools via MCP Hub (`list-all-tools`, `call-tool`, `get-tool-info`)

### Proactive Problem Fixing
- Automatically detect and fix: TypeScript errors, lint errors, test failures, performance issues, security issues, code quality issues
- Automatically suggest and implement improvements: Code duplication, missing error handling, performance bottlenecks, security vulnerabilities, missing tests, inconsistent patterns

### Code Generation Best Practices
- Generate complete solutions: Include error handling, type hints, and tests
- Use existing patterns: Match the style and structure of similar code
- Include comments: For complex logic or non-obvious decisions
- Add docstrings: For public functions, classes, and complex methods
- Consider edge cases: Handle null/undefined, empty arrays, network failures
- Validate inputs: Always validate user input and API responses

## üéØ Best Practices

### When Adding New Features
1. **Backend Route** (Follow FastAPI Route Pattern):
   - Create Pydantic request/response models
   - Add route with dependency injection (`Annotated[Type, Depends()]`)
   - Implement service method (business logic)
   - Add repository method if needed (use eager loading)
   - Write tests (success + error cases)
   - Register router in `main.py`

2. **Frontend Integration** (Follow React Query Hook Pattern):
   - Add API function in `client/src/lib/api.ts` (normalize trading modes)
   - Create React Query hook in `client/src/hooks/useApi.ts` (use `useAuth()`, set `enabled`, `staleTime`)
   - Build UI component with shadcn/ui
   - Handle loading/error states

3. **Documentation & Storage**:
   - Update API docs (OpenAPI auto-generated)
   - Store pattern in Memory-Bank if new pattern discovered

### When Debugging
- **Backend**: Check logs (`logs/fastapi.log`), test API endpoints (`http://localhost:8000/docs`), use pytest with `-v` flag
- **Frontend**: Browser console, React DevTools, React Query DevTools, Network tab
- **E2E**: Use Playwright UI mode (`npm run test:e2e:ui`), review trace viewer, check screenshots/videos

### Code Search Strategy
**REQUIRED: Use Intelligence System FIRST**:
1. Read `.cursor/extracted-patterns.md` - Find matching patterns (103 patterns available)
2. Read `.cursor/knowledge-base.md` - Check for existing solutions
3. Use Memory-Bank: `read_global_memory_bank({ docs: ".cursor" })` - Retrieve stored patterns
4. Check `.cursor/predictive-suggestions.md` - Get proactive suggestions

**Before implementing, always**:
- Search for similar functionality using `codebase_search`
- Check existing patterns in related files
- Match extracted patterns from `.cursor/extracted-patterns.md`

## üîß MCP (Model Context Protocol) Integration

### MCP Hub - Recommended Solution
- **Configuration**: Configured in `~/.cursor/mcp-hub.json` (not `mcp.json`)
- **Usage**: Enable only `mcp-hub` in Cursor Settings, disable all individual servers
- **Benefits**: Exposes only 2-3 tools to Cursor (bypasses 40-tool limit), routes tool calls automatically

### Required MCP Servers
- **CoinGecko MCP**: Real-time crypto prices, market data, historical OHLCV
- **Web3 MCP**: Multi-chain blockchain interactions (Ethereum, Base, Arbitrum, etc.)
- **DeFi Trading MCP**: Portfolio analysis and trading
- **PostgreSQL MCP**: Read-only database access
- **Redis MCP**: Redis key-value store interaction
- **SQLite MCP**: Development database operations (`pip install mcp-server-sqlite`)
- **Context7**: Latest library documentation (FastAPI, React, TypeScript, Web3.py)
- **StackOverflow**: Community solutions and error troubleshooting
- **Brave Search**: Best practices and security recommendations

### When to Use MCPs
- **Cryptocurrency data** ‚Üí CoinGecko MCP
- **Blockchain operations** ‚Üí Web3 MCP
- **Trading/portfolio** ‚Üí DeFi Trading MCP
- **Library docs** ‚Üí Context7
- **Error troubleshooting** ‚Üí StackOverflow
- **Best practices** ‚Üí Brave Search
- **Database operations** ‚Üí Postgres/SQLite MCP

### MCP Troubleshooting
- **High tool count**: Disable individual servers in Cursor Settings, enable only `mcp-hub`
- **Server not appearing**: Check `mcp-hub.json` configuration and environment variables
- **Python module errors**: Verify `mcp-server-sqlite` and `arxiv-search-mcp` are installed correctly

## üö® Critical Rules

1. **Never expose sensitive data** in logs or error messages (API keys, passwords, tokens, private keys)
2. **Always validate user input** before processing (Pydantic models, Zod schemas)
3. **Use type hints** (Python) and TypeScript types (frontend) - strict mode enabled
4. **Handle errors gracefully** with user-friendly messages and structured error responses
5. **Test before deploying** - run tests locally first, check coverage (85%+ required)
6. **Follow existing patterns** - don't reinvent the wheel, check similar implementations
7. **Keep routes thin** - business logic in services, routes handle HTTP concerns only
8. **Use dependency injection with Annotated** - don't instantiate services directly, use `Depends()` with `Annotated` type hints
9. **Check Redis availability** before using cache features (optional dependency)
10. **Normalize trading modes** - "live" ‚Üí "real" for backend compatibility
11. **Use `yield` in dependencies** for resources requiring cleanup (DB sessions, connections)
12. **Async/await properly** - use `async def` for I/O operations, don't block event loop
13. **Search codebase first** - understand existing patterns before implementing new features
14. **Encrypt sensitive data** - API keys, credentials, wallet private keys should be encrypted at rest
15. **Implement DEX aggregator fallback** - use multiple aggregators (0x, OKX, Rubic) with fallback logic
16. **Handle blockchain RPC errors** - implement retries with exponential backoff
17. **Validate price impact** - warn users if price impact exceeds threshold (>1%)
18. **Require 2FA for high-value operations** - withdrawals and large trades
19. **Use eager loading** - prevent N+1 queries with `selectinload`/`joinedload`
20. **Implement pagination** - use `QueryOptimizer.paginate_query()` for database queries

## üìö Reference Files

### Core Documentation
- **Architecture**: `docs/architecture.md`
- **API Docs**: `http://localhost:8000/docs` (Swagger UI)
- **Project Status**: `PROJECT_AUDIT_REPORT.md`

### Cursor Rules & Configuration
- **Frontend Rules**: `.cursor/rules/cursor-frontend.mdc`
- **Backend Rules**: `.cursor/rules/cursor-backend.mdc`
- **Architect Mode**: `.cursor/rules/cursor-architect-mode.mdc`
- **YOLO Mode**: `.cursor/rules/cursor-yolo-mode.mdc`
- **MCP Hub Setup**: `.cursor/rules/MCP_HUB_SETUP.md`
- **Agent Optimization**: `.cursor/rules/CURSOR_AGENT_OPTIMIZATION.md`

### Knowledge Base & Intelligence (AUTOMATIC USAGE REQUIRED)
- **Knowledge Base**: `.cursor/knowledge-base.md` - Common patterns, solutions, learnings
- **Extracted Patterns**: `.cursor/extracted-patterns.md` - Real patterns from codebase (103 patterns extracted)
- **Quick Reference**: `.cursor/quick-reference.md` - Fast lookup for common patterns
- **Intelligence Heuristics**: `.cursor/intelligence-heuristics.md` - Decision-making rules (80+ heuristics)
- **Predictive Suggestions**: `.cursor/predictive-suggestions.md` - Proactive improvement suggestions
- **Decisions Log**: `.cursor/decisions.md` - Architectural decisions with rationale

**Memory-Bank MCP**: Use `read_global_memory_bank` to retrieve stored patterns and decisions

---

## üéØ FINAL REMINDER: AUTONOMOUS OPERATION

**This agent operates in FULLY AUTONOMOUS MODE by default.**

### What the Agent AUTOMATICALLY Does (NO ASKING):
1. ‚úÖ Uses ALL tools automatically - 150+ MCP tools, codebase tools, intelligence system
2. ‚úÖ Researches automatically - Intelligence files, codebase search, MCP tools, web research
3. ‚úÖ Plans automatically - Architect Mode for complex, YOLO Mode for simple
4. ‚úÖ Implements automatically - Complete solutions with tests, docs, error handling
5. ‚úÖ Fixes issues automatically - TypeScript errors, lint errors, test failures, performance issues
6. ‚úÖ Verifies automatically - Runs tests, checks errors, validates fixes
7. ‚úÖ Learns automatically - Stores patterns, updates knowledge base, documents decisions

### What the Agent NEVER Asks For:
- ‚ùå Tool usage - use all tools automatically
- ‚ùå Research permission - research automatically
- ‚ùå Planning approval - plan automatically
- ‚ùå Implementation confirmation - implement automatically
- ‚ùå Fix permission - fix issues automatically
- ‚ùå Test permission - test automatically
- ‚ùå Verification permission - verify automatically

### What the Agent ONLY Asks For (RARE - < 5% of cases):
- ‚úÖ Requirements are genuinely ambiguous (truly unclear, not just complex)
- ‚úÖ Multiple valid approaches exist AND trade-offs significantly affect user experience
- ‚úÖ Security implications need user awareness (but still proceed with best practice)
- ‚úÖ Breaking changes that affect user's workflow (but still implement with migration path)

**Remember**: This is a production-ready, enterprise-grade trading platform. Always prioritize:
- **Security** over convenience
- **Reliability** over speed (when in doubt)
- **Clarity** over cleverness
- **Testing** before deployment (unit, integration, E2E)
- **Documentation** for complex features
- **Autonomous operation** - act independently, use all tools, research automatically, implement proactively
