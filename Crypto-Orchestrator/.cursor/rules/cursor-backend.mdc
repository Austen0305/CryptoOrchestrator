---
alwaysApply: true
description: "Backend development rules for CryptoOrchestrator - FastAPI (legacy) and Rust/Actix-Web (new)"
---
# CryptoOrchestrator - Backend Development Rules

> **Current Date**: December 11, 2025  
> **Last Updated**: 2025-12-11

You are an expert backend software engineer specializing in this production-ready cryptocurrency trading automation platform. Follow these rules when working on backend code.

> **Note**: The project uses the optimized FastAPI (Python) stack for maximum performance and production readiness.

## üèóÔ∏è Backend Stack & Architecture

### Production Stack (FastAPI - Active)
- **Framework**: FastAPI 0.104+ with async/await patterns
- **Language**: Python 3.11+ with type hints (mypy strict mode)
- **Database**: 
  - PostgreSQL (production) via asyncpg with automated backups
  - SQLite (development) via aiosqlite
- **ORM**: SQLAlchemy 2.0+ (async) with Alembic migrations and automated testing
- **Cache**: Redis (optional, always check availability) with multi-level caching
- **Background Jobs**: Celery 5.3+ with Redis broker, prioritization, and batching
- **Authentication**: JWT tokens with bcrypt password hashing
- **API Documentation**: OpenAPI/Swagger (auto-generated) with comprehensive examples
- **Validation**: Pydantic v2 models
- **Backup & Recovery**: Automated database backups with S3 support and point-in-time recovery


### Directory Structure
```
server_fastapi/
‚îú‚îÄ‚îÄ routes/              # API endpoints (thin controllers)
‚îÇ   ‚îú‚îÄ‚îÄ bots.py         # Bot endpoints
‚îÇ   ‚îú‚îÄ‚îÄ trades.py       # Trade endpoints
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ services/            # Business logic (stateless preferred)
‚îÇ   ‚îú‚îÄ‚îÄ bot_service.py
‚îÇ   ‚îú‚îÄ‚îÄ trading_service.py
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ models/              # SQLAlchemy ORM models
‚îÇ   ‚îú‚îÄ‚îÄ bot.py
‚îÇ   ‚îú‚îÄ‚îÄ trade.py
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ repositories/        # Data access layer
‚îÇ   ‚îú‚îÄ‚îÄ bot_repository.py
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ middleware/          # Request/response middleware
‚îÇ   ‚îú‚îÄ‚îÄ auth.py
‚îÇ   ‚îú‚îÄ‚îÄ error_handler.py
‚îÇ   ‚îú‚îÄ‚îÄ query_cache.py  # Query result caching
‚îÇ   ‚îú‚îÄ‚îÄ compression.py # Response compression
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ utils/               # Backend utilities
‚îÇ   ‚îú‚îÄ‚îÄ query_optimizer.py  # Query optimization (eager loading, pagination, N+1 prevention)
‚îÇ   ‚îú‚îÄ‚îÄ cache_utils.py      # Multi-level caching (memory + Redis)
‚îÇ   ‚îî‚îÄ‚îÄ response_optimizer.py  # Response optimization (pagination, field selection, streaming)
‚îú‚îÄ‚îÄ dependencies/        # FastAPI dependencies
‚îÇ   ‚îú‚îÄ‚îÄ auth.py         # Authentication dependencies
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ config/              # Configuration
‚îÇ   ‚îî‚îÄ‚îÄ settings.py     # Pydantic settings
‚îú‚îÄ‚îÄ tests/               # Pytest tests
‚îî‚îÄ‚îÄ main.py             # App factory & middleware setup
```

---

## üîå API Design Patterns

### Route Structure
```python
# ‚úÖ Good: Mounted under /api/<domain>, organized by OpenAPI tags
from fastapi import APIRouter
from typing import Annotated
from fastapi import Depends

router = APIRouter()

@router.get('/bots', tags=['Bots'])
async def get_bots(
    current_user: Annotated[dict, Depends(validate_jwt_and_get_user)],
    service: Annotated[BotService, Depends(get_bot_service)],
):
    return await service.get_bots(user_id=current_user['id'])

# In main.py:
app.include_router(router, prefix='/api/bots', tags=['Bots'])
```

### Request/Response Models
```python
# ‚úÖ Good: Pydantic models with examples and validation
from pydantic import BaseModel, Field
from typing import Optional

class CreateBotRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    strategy: str = Field(..., pattern='^(momentum|mean_reversion)$')
    initial_balance: float = Field(..., gt=0)
    
    model_config = {
        "json_schema_extra": {
            "example": {
                "name": "My Trading Bot",
                "strategy": "momentum",
                "initial_balance": 1000.0
            }
        }
    }

class BotResponse(BaseModel):
    id: str
    name: str
    strategy: str
    status: str
    created_at: datetime
    
    model_config = {"from_attributes": True}  # SQLAlchemy model conversion
```

### Dependency Injection Pattern
```python
# ‚úÖ Use Depends() for services and resources
from fastapi import Depends
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession

async def get_db_session() -> AsyncSession:
    """Database session dependency with cleanup."""
    async with AsyncSession(engine) as session:
        try:
            yield session
        except HTTPException:
            await session.rollback()
            raise
        finally:
            await session.close()

@router.post('/bots', response_model=BotResponse)
async def create_bot(
    request: CreateBotRequest,
    current_user: Annotated[dict, Depends(validate_jwt_and_get_user)],
    service: Annotated[BotService, Depends(get_bot_service)],
    db: Annotated[AsyncSession, Depends(get_db_session)],
):
    return await service.create_bot(
        request, 
        user_id=current_user['id'], 
        db=db
    )
```

### Error Handling
```python
# ‚úÖ Use HTTPException for expected errors
from fastapi import HTTPException
import logging

logger = logging.getLogger(__name__)

@router.post('/bots')
async def create_bot(...):
    try:
        return await service.create_bot(request, user_id, db)
    except ValidationError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except BotNotFoundError as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        logger.error(
            f"Failed to create bot: {e}", 
            exc_info=True, 
            extra={"user_id": user_id, "bot_name": request.name}
        )
        raise HTTPException(status_code=500, detail="Internal server error")
```

### Logging Standards
```python
# ‚úÖ Always use module logger, include context
import logging

logger = logging.getLogger(__name__)  # Never configure logging in modules

logger.info("Bot created", extra={"bot_id": bot_id, "user_id": user_id})
logger.error("Failed to create bot", exc_info=True, extra={"user_id": user_id})
logger.warning("Rate limit approaching", extra={"user_id": user_id, "requests": count})

# ‚ùå Never log sensitive data (API keys, passwords, tokens)
# Use LogSanitizer middleware for automatic sanitization
```

---

## üóÑÔ∏è Database Patterns

### SQLAlchemy Async Models
```python
# ‚úÖ Async SQLAlchemy model with proper typing
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column
from datetime import datetime
from uuid import uuid4

class Base(DeclarativeBase):
    pass

class Bot(Base):
    __tablename__ = "bots"
    
    id: Mapped[str] = mapped_column(primary_key=True, default=lambda: str(uuid4()))
    name: Mapped[str]
    strategy: Mapped[str]
    user_id: Mapped[str]
    status: Mapped[str] = mapped_column(default="stopped")
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
```

### Repository Pattern
```python
# ‚úÖ Repository handles data access, service handles business logic
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

class BotRepository:
    def __init__(self, db: AsyncSession):
        self.db = db
    
    async def get_bots_by_user(self, user_id: str) -> list[Bot]:
        result = await self.db.execute(
            select(Bot).where(Bot.user_id == user_id)
        )
        return list(result.scalars().all())
    
    async def create_bot(self, bot: Bot) -> Bot:
        self.db.add(bot)
        await self.db.commit()
        await self.db.refresh(bot)
        return bot
```

### Service Pattern
```python
# ‚úÖ Service handles business logic, uses repository for data access
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession

class BotService:
    def __init__(self, db: AsyncSession):
        self.repository = BotRepository(db)
    
    async def create_bot(
        self, 
        request: CreateBotRequest, 
        user_id: str
    ) -> Bot:
        # Business logic: validate, transform, create
        bot = Bot(
            name=request.name,
            strategy=request.strategy,
            user_id=user_id,
            status="stopped"
        )
        return await self.repository.create_bot(bot)
```

---

## üîí Security Patterns

### Authentication & Authorization
```python
# ‚úÖ JWT validation dependency
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt

security = HTTPBearer()

async def validate_jwt_and_get_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> dict:
    try:
        token = credentials.credentials
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user_id = payload.get("sub")
        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid token")
        return {"id": user_id, "email": payload.get("email")}
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

# ‚úÖ Check ownership before operations
@router.delete('/bots/{bot_id}')
async def delete_bot(
    bot_id: str,
    current_user: Annotated[dict, Depends(validate_jwt_and_get_user)],
    service: Annotated[BotService, Depends(get_bot_service)],
    db: Annotated[AsyncSession, Depends(get_db_session)],
):
    bot = await service.get_bot(bot_id, db)
    if bot.user_id != current_user['id']:
        raise HTTPException(status_code=403, detail="Not authorized")
    return await service.delete_bot(bot_id, db)
```

### Input Validation
```python
# ‚úÖ Pydantic validation (automatic via FastAPI)
class CreateBotRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    strategy: str = Field(..., pattern='^(momentum|mean_reversion)$')
    
# ‚úÖ Sanitize inputs before logging
from bleach import clean

logger.info(f"Bot created: {clean(request.name)}")  # Sanitize user input
```

### Secrets Management
```python
# ‚úÖ Use pydantic-settings for environment variables
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    database_url: str
    secret_key: str
    redis_url: Optional[str] = None
    wallet_encryption_key: str  # For encrypting private keys
    
    model_config = {"env_file": ".env", "env_file_encoding": "utf-8"}

settings = Settings()

# ‚úÖ Never log secrets
# ‚ùå logger.info(f"API key: {api_key}")  # NEVER DO THIS
# ‚ùå logger.info(f"Private key: {private_key}")  # NEVER DO THIS
```

### Crypto-Specific Security Patterns

**Real Money Trading Security:**
```python
# ‚úÖ Require 2FA for withdrawals and high-value trades
from typing import Annotated
from fastapi import Depends, HTTPException

async def require_2fa_for_withdrawal(
    current_user: Annotated[dict, Depends(validate_jwt_and_get_user)],
    amount: float,
    db: AsyncSession
) -> bool:
    """Require 2FA for withdrawals above threshold."""
    threshold = 100.0  # $100 threshold
    
    if amount > threshold:
        # Check if 2FA is enabled and verified
        user = await get_user(current_user['id'], db)
        if not user.two_factor_enabled:
            raise HTTPException(
                status_code=403,
                detail="2FA required for withdrawals above threshold"
            )
        # Verify 2FA token (implementation depends on 2FA method)
        if not await verify_2fa_token(current_user['id'], db):
            raise HTTPException(
                status_code=403,
                detail="Invalid 2FA token"
            )
    return True

# ‚úÖ Withdrawal address whitelisting with cooldown
async def validate_withdrawal_address(
    address: str,
    user_id: str,
    db: AsyncSession
) -> bool:
    """Validate withdrawal address with 24-hour cooldown."""
    whitelist = await get_whitelisted_addresses(user_id, db)
    
    if address not in whitelist:
        raise HTTPException(
            status_code=400,
            detail="Address not whitelisted. Add address and wait 24 hours."
        )
    
    # Check cooldown period (24 hours)
    last_added = await get_address_added_time(address, user_id, db)
    if last_added and (datetime.utcnow() - last_added).total_seconds() < 86400:
        raise HTTPException(
            status_code=400,
            detail="Address whitelist cooldown: 24 hours required"
        )
    
    return True
```

**Wallet Private Key Security:**
```python
# ‚úÖ Encrypt private keys at rest
from cryptography.fernet import Fernet
from typing import Annotated

class WalletSecurityService:
    def __init__(self, encryption_key: str):
        self.cipher = Fernet(encryption_key.encode())
    
    def encrypt_private_key(self, private_key: str) -> str:
        """Encrypt private key for storage."""
        encrypted = self.cipher.encrypt(private_key.encode())
        return encrypted.decode()
    
    def decrypt_private_key(self, encrypted_key: str) -> str:
        """Decrypt private key for use."""
        decrypted = self.cipher.decrypt(encrypted_key.encode())
        return decrypted.decode()
    
    # ‚úÖ Never log private keys
    # ‚ùå logger.info(f"Private key: {private_key}")  # NEVER DO THIS
    # ‚úÖ Log only wallet address (public)
    # ‚úÖ logger.info(f"Wallet address: {address}")  # OK
```

**Transaction Safety:**
```python
# ‚úÖ Idempotent transaction processing
from typing import Annotated
import hashlib

async def execute_transaction_safely(
    request: SwapRequest,
    user_id: str,
    db: AsyncSession
) -> dict:
    """Execute transaction with idempotency check."""
    # Generate idempotency key from request
    idempotency_key = hashlib.sha256(
        f"{user_id}:{request.token_in}:{request.token_out}:{request.amount}".encode()
    ).hexdigest()
    
    # Check if transaction already processed
    existing = await get_transaction_by_idempotency_key(idempotency_key, db)
    if existing:
        return existing  # Return existing result
    
    # Execute transaction
    result = await execute_swap(request, user_id, db)
    
    # Store idempotency key
    await store_idempotency_key(idempotency_key, result['tx_hash'], db)
    
    return result
```

---

## üß™ Testing Patterns

### Complete E2E Testing Infrastructure

**NEW**: Comprehensive end-to-end testing infrastructure with automated service management.

#### Test Database Setup
- **Script**: `scripts/test_db_setup.py`
  - Creates test database (SQLite by default)
  - Runs Alembic migrations
  - Handles errors gracefully
  - Used by E2E test global setup

#### Service Management for Testing
- **Service Manager**: `scripts/service-manager.js`
  - Starts PostgreSQL (Docker or local)
  - Starts Redis (Docker or local)
  - Manages FastAPI backend process
  - Manages React frontend process
  - Handles graceful shutdown
- **Usage in Tests**: Import and use ServiceManager in test setup
  ```javascript
  import ServiceManager from './scripts/service-manager.js';
  const manager = new ServiceManager();
  await manager.startAll();
  // Run tests
  manager.stopAll();
  ```

#### Environment Validation
- **Validator**: `scripts/validate-environment.js`
  - Checks required environment variables
  - Verifies Python and Node.js installations
  - Validates dependencies
  - Checks port availability
- **Pre-Flight Check**: `scripts/preflight-check.js`
  - Validates readiness before tests
  - Checks dependencies and environment
  - Verifies service accessibility

### Route Tests (pytest + httpx)
```python
# ‚úÖ Test routes with test client and fixtures
import pytest
from httpx import AsyncClient
from fastapi.testclient import TestClient

@pytest.mark.asyncio
async def test_create_bot_success(client: AsyncClient, test_user: dict):
    response = await client.post(
        "/api/bots",
        json={"name": "Test Bot", "strategy": "momentum", "initial_balance": 1000.0},
        headers={"Authorization": f"Bearer {test_user['token']}"}
    )
    assert response.status_code == 200
    data = response.json()
    assert data["name"] == "Test Bot"
    assert data["strategy"] == "momentum"

@pytest.mark.asyncio
async def test_create_bot_validation_error(client: AsyncClient, test_user: dict):
    response = await client.post(
        "/api/bots",
        json={},  # Missing required fields
        headers={"Authorization": f"Bearer {test_user['token']}"}
    )
    assert response.status_code == 422  # Validation error
```

### Service Tests
```python
# ‚úÖ Test business logic in isolation
@pytest.mark.asyncio
async def test_create_bot_service(test_db: AsyncSession):
    service = BotService(test_db)
    request = CreateBotRequest(
        name="Test Bot",
        strategy="momentum",
        initial_balance=1000.0
    )
    bot = await service.create_bot(request, user_id="test-user-id")
    assert bot.name == "Test Bot"
    assert bot.status == "stopped"
```

### Test Fixtures
```python
# ‚úÖ Use pytest fixtures for test setup
import pytest
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

@pytest.fixture
async def test_db():
    engine = create_async_engine("sqlite+aiosqlite:///:memory:")
    async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
    async with async_session() as session:
        yield session
    await engine.dispose()

@pytest.fixture
def test_user():
    return {
        "id": "test-user-id",
        "email": "test@example.com",
        "token": "test-jwt-token"
    }
```

### E2E Test Setup
- **Global Setup**: `tests/e2e/global-setup.ts`
  - Enhanced with better error handling
  - Service dependency checks
  - Windows compatibility
  - Health check retries with exponential backoff
  - Uses `scripts/test_db_setup.py` for database setup

---

## ‚ö° Performance Optimization

### Query Optimization
```python
# ‚úÖ Use QueryOptimizer for eager loading to prevent N+1 queries
from ..utils.query_optimizer import QueryOptimizer
from sqlalchemy.orm import selectinload, joinedload

# Eager load relationships
query = select(Bot).where(Bot.user_id == user_id)
query = query.options(joinedload(Bot.user))  # Prevents N+1 queries

# Or use QueryOptimizer utility
query = QueryOptimizer.eager_load_relationships(
    query,
    relationships=['user', 'trades'],
    use_joinedload=True
)

# Add pagination
query = QueryOptimizer.paginate_query(query, page=1, page_size=20)
```

### Multi-Level Caching
```python
# ‚úÖ Use MultiLevelCache for memory + Redis caching
from ..utils.cache_utils import MultiLevelCache, CacheKeyGenerator

cache = MultiLevelCache(redis_client=redis_client)

# Get from cache (memory first, then Redis)
value = await cache.get("key", default=None)

# Set in cache (both memory and Redis)
await cache.set("key", value, ttl=300)

# Invalidate by tag
await cache.invalidate_tag("bots")
```

### Response Optimization
```python
# ‚úÖ Use ResponseOptimizer for optimized API responses
from ..utils.response_optimizer import ResponseOptimizer

# Paginated response with metadata
paginated = ResponseOptimizer.paginate_response(
    data, page=1, page_size=20, total=100
)

# Filter null fields to reduce payload
filtered = ResponseOptimizer.filter_null_fields(data)

# Select only specified fields (sparse fieldsets)
selected = ResponseOptimizer.select_fields(data, fields=['id', 'name'])
```

### Async/Await
```python
# ‚úÖ Use async for I/O operations
async def get_bot(bot_id: str, db: AsyncSession) -> Bot:
    result = await db.execute(select(Bot).where(Bot.id == bot_id))
    return result.scalar_one_or_none()

# ‚ùå Don't block event loop
# result = db.execute(select(Bot).where(Bot.id == bot_id))  # Synchronous
```

### Database Connection Pooling
```python
# ‚úÖ Use connection pooling with settings from config
from ..config.settings import Settings
settings = Settings()

engine = create_async_engine(
    DATABASE_URL,
    pool_size=settings.db_pool_size,  # From settings
    max_overflow=settings.db_max_overflow,
    pool_timeout=settings.db_pool_timeout,
    pool_recycle=settings.db_pool_recycle,
    pool_pre_ping=True,  # Verify connections before using
)
```

### Caching with Redis
```python
# ‚úÖ Check Redis availability before using
from typing import Optional
import redis.asyncio as redis
from ..utils.cache_utils import MultiLevelCache

redis_client: Optional[redis.Redis] = None
cache = MultiLevelCache(redis_client=redis_client)

async def get_cache(key: str) -> Optional[str]:
    if cache:
        try:
            return await cache.get(key)
        except Exception as e:
            logger.warning(f"Cache error: {e}", exc_info=True)
    return None
```

### Rate Limiting
```python
# ‚úÖ Use SlowAPI for rate limiting
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)

@router.post('/bots')
@limiter.limit("10/minute")
async def create_bot(...):
    ...
```

---

## üîÑ Trading-Specific Patterns

### DEX Trading Integration

**Note**: The platform uses **blockchain/DEX trading exclusively**. Exchange integrations via CCXT are deprecated.

```python
# ‚úÖ DEX aggregator service pattern
from typing import Annotated
from fastapi import Depends, HTTPException

class DexAggregatorService:
    async def get_quote(
        self,
        token_in: str,
        token_out: str,
        amount: float,
        chain: str
    ) -> dict:
        """Get best quote from multiple DEX aggregators."""
        quotes = []
        for aggregator in [self.zero_x, self.okx, self.rubic]:
            try:
                quote = await aggregator.get_quote(token_in, token_out, amount, chain)
                quotes.append(quote)
            except Exception as e:
                logger.warning(f"{aggregator} failed: {e}")
                continue
        
        if not quotes:
            raise HTTPException(status_code=503, detail="No DEX aggregators available")
        
        # Return best quote (lowest price impact)
        return min(quotes, key=lambda q: q['price_impact'])
```

**Transaction Batching:**
- Use `TransactionBatcher` service for gas optimization
- Batch multiple swaps into single transaction (30-60% savings)
- Automatic for bot trades, optional for manual trades

**MEV Protection:**
- Auto-enabled for trades > $1000 USD
- Integrates with MEV Blocker (multi-chain)
- Protects from front-running and sandwich attacks

### Database Query Optimization
```python
# ‚úÖ Use QueryOptimizer for optimized queries
from ..utils.query_optimizer import QueryOptimizer
from sqlalchemy.orm import selectinload, joinedload

# Prevent N+1 queries with eager loading
query = select(Trade).where(Trade.user_id == user_id)
query = query.options(
    selectinload(Trade.user),
    selectinload(Trade.bot),
    selectinload(Trade.order)
)

# Add pagination
query = QueryOptimizer.paginate_query(query, page=1, page_size=20)

# Get total count efficiently
total = await QueryOptimizer.count_query(session, Trade, filters={'user_id': user_id})
```

### Response Optimization
```python
# ‚úÖ Use ResponseOptimizer for optimized API responses
from ..utils.response_optimizer import ResponseOptimizer
from fastapi import Response

@router.get("/bots")
async def get_bots(
    page: int = Query(1, ge=1),
    page_size: int = Query(20, ge=1, le=100),
    response: Response = None
):
    bots = await service.get_bots()
    total = len(bots)
    
    # Create paginated response
    paginated = ResponseOptimizer.paginate_response(bots, page, page_size, total)
    
    # Add cache headers
    ResponseOptimizer.add_cache_headers(response, max_age=60)
    
    return paginated
```

### DEX Aggregator Integration

**Multi-Aggregator Pattern with Fallback:**
```python
# ‚úÖ DEX aggregator service with fallback logic
from typing import Annotated
from fastapi import Depends, HTTPException
from web3 import Web3
import httpx

class DexAggregatorService:
    def __init__(self):
        self.aggregators = {
            '0x': 'https://api.0x.org/swap/v1/quote',
            'okx': 'https://www.okx.com/api/v5/dex/aggregator/quote',
            'rubic': 'https://api.rubic.exchange/api/v1/quote',
        }
    
    async def get_best_quote(
        self,
        token_in: str,
        token_out: str,
        amount: float,
        chain: str,
        slippage: float = 0.005  # 0.5% default
    ) -> dict:
        """Get best quote from multiple DEX aggregators with fallback."""
        quotes = []
        
        for name, base_url in self.aggregators.items():
            try:
                quote = await self._get_quote_from_aggregator(
                    name, base_url, token_in, token_out, amount, chain
                )
                if quote and quote.get('price_impact', 1) < 0.05:  # 5% max impact
                    quotes.append({**quote, 'aggregator': name})
            except Exception as e:
                logger.warning(f"{name} aggregator failed: {e}", exc_info=True)
                continue
        
        if not quotes:
            raise HTTPException(
                status_code=503,
                detail="No DEX aggregators available"
            )
        
        # Return best quote (lowest price impact)
        best_quote = min(quotes, key=lambda q: q.get('price_impact', 1))
        return best_quote
    
    async def execute_swap(
        self,
        quote: dict,
        wallet_address: str,
        private_key: str,  # Encrypted
        chain: str
    ) -> dict:
        """Execute swap transaction on blockchain."""
        w3 = self._get_web3_instance(chain)
        
        # Decrypt private key
        decrypted_key = self._decrypt_private_key(private_key)
        
        # Build transaction
        tx = await self._build_swap_transaction(quote, wallet_address, w3)
        
        # Sign and send
        signed_tx = w3.eth.account.sign_transaction(tx, decrypted_key)
        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        
        return {
            'tx_hash': tx_hash.hex(),
            'status': 'pending',
            'chain': chain,
            'aggregator': quote['aggregator']
        }
```

**Price Impact Calculation:**
```python
# ‚úÖ Calculate price impact before swaps
async def calculate_price_impact(
    self,
    token_in: str,
    token_out: str,
    amount: float,
    chain: str
) -> float:
    """Calculate price impact for swap."""
    # Get current spot price
    spot_price = await self._get_spot_price(token_in, token_out, chain)
    
    # Get quote price
    quote = await self.get_best_quote(token_in, token_out, amount, chain)
    quote_price = quote['price']
    
    # Calculate impact: (quote_price - spot_price) / spot_price
    price_impact = abs((quote_price - spot_price) / spot_price)
    
    return price_impact
```

### Multi-Chain Wallet Service

**Wallet Management:**
```python
# ‚úÖ Multi-chain wallet service
from typing import Annotated
from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
from cryptography.fernet import Fernet

class MultiChainWalletService:
    def __init__(self, encryption_key: str):
        self.encryption = Fernet(encryption_key.encode())
        self.chains = {
            'ethereum': Web3(Web3.HTTPProvider(settings.ETH_RPC_URL)),
            'base': Web3(Web3.HTTPProvider(settings.BASE_RPC_URL)),
            'arbitrum': Web3(Web3.HTTPProvider(settings.ARB_RPC_URL)),
            'polygon': Web3(Web3.HTTPProvider(settings.POLYGON_RPC_URL)),
            # Add more chains as needed
        }
        
        # Add POA middleware for some chains
        for chain_name in ['base', 'arbitrum', 'polygon']:
            self.chains[chain_name].middleware_onion.inject(
                geth_poa_middleware, layer=0
            )
    
    async def create_wallet(self, user_id: str, chain: str) -> dict:
        """Create new wallet for user on specified chain."""
        account = Account.create()
        
        # Encrypt private key
        encrypted_key = self.encryption.encrypt(
            account.key.hex().encode()
        ).decode()
        
        # Store in database (encrypted)
        wallet = Wallet(
            user_id=user_id,
            address=account.address,
            chain=chain,
            encrypted_private_key=encrypted_key,
            is_custodial=True
        )
        
        return {
            'address': account.address,
            'chain': chain,
            'is_custodial': True
        }
    
    async def get_balance(
        self,
        address: str,
        chain: str,
        token_address: str | None = None
    ) -> float:
        """Get balance for address on specified chain."""
        w3 = self.chains[chain]
        
        if token_address:
            # ERC-20 token balance
            return await self._get_erc20_balance(w3, address, token_address)
        else:
            # Native token balance (ETH, MATIC, etc.)
            balance_wei = w3.eth.get_balance(address)
            decimals = 18  # Most chains use 18 decimals
            return balance_wei / (10 ** decimals)
    
    async def send_transaction(
        self,
        from_address: str,
        to_address: str,
        amount: float,
        chain: str,
        user_id: str
    ) -> dict:
        """Send transaction on specified chain."""
        # Get encrypted private key from database
        wallet = await self._get_wallet(from_address, user_id, chain)
        
        # Decrypt private key
        private_key = self.encryption.decrypt(
            wallet.encrypted_private_key.encode()
        ).decode()
        
        w3 = self.chains[chain]
        account = Account.from_key(private_key)
        
        # Build transaction
        nonce = w3.eth.get_transaction_count(from_address)
        gas_price = w3.eth.gas_price
        
        tx = {
            'nonce': nonce,
            'to': to_address,
            'value': w3.to_wei(amount, 'ether'),
            'gas': 21000,  # Standard transfer
            'gasPrice': gas_price,
            'chainId': self._get_chain_id(chain),
        }
        
        # Sign and send
        signed_tx = account.sign_transaction(tx)
        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        
        return {
            'tx_hash': tx_hash.hex(),
            'status': 'pending',
            'chain': chain
        }
```

**Gas Fee Optimization:**
```python
# ‚úÖ Gas fee optimization
async def estimate_gas_fee(
    self,
    chain: str,
    priority: str = 'standard'  # 'slow', 'standard', 'fast'
) -> dict:
    """Estimate gas fees with priority levels."""
    w3 = self.chains[chain]
    
    try:
        # Try EIP-1559 fee structure
        fee_data = w3.eth.fee_history(1, 'latest')
        base_fee = fee_data['baseFeePerGas'][0]
        
        if priority == 'slow':
            max_priority_fee = base_fee * 0.1
        elif priority == 'standard':
            max_priority_fee = base_fee * 0.2
        else:  # fast
            max_priority_fee = base_fee * 0.5
        
        return {
            'max_fee_per_gas': base_fee + max_priority_fee,
            'max_priority_fee_per_gas': max_priority_fee,
            'gas_price': None,  # EIP-1559
        }
    except Exception:
        # Fallback to legacy gas price
        gas_price = w3.eth.gas_price
        multiplier = {'slow': 0.9, 'standard': 1.0, 'fast': 1.2}[priority]
        
        return {
            'max_fee_per_gas': None,
            'max_priority_fee_per_gas': None,
            'gas_price': int(gas_price * multiplier),
        }
```

### Trading Mode Normalization
```python
# ‚úÖ Normalize "live" to "real" for backend compatibility
def normalize_trading_mode(mode: str) -> str:
    """Normalize trading mode: 'live' -> 'real'."""
    return "real" if mode == "live" else mode

@router.get('/portfolio')
async def get_portfolio(
    mode: str = Query(..., pattern='^(paper|real|live)$'),
    ...
):
    normalized_mode = normalize_trading_mode(mode)
    return await service.get_portfolio(mode=normalized_mode, ...)
```

### Risk Management
```python
# ‚úÖ Validate risk limits before trades
class RiskService:
    async def validate_trade(
        self, 
        user_id: str, 
        trade_amount: float,
        db: AsyncSession
    ) -> bool:
        risk_limits = await self.get_risk_limits(user_id, db)
        current_exposure = await self.get_current_exposure(user_id, db)
        
        if current_exposure + trade_amount > risk_limits.max_exposure:
            raise HTTPException(
                status_code=400, 
                detail="Trade exceeds risk limits"
            )
        return True
```

### Blockchain Interaction Patterns (Web3.py)

**Multi-Chain RPC Management:**
```python
# ‚úÖ Multi-chain Web3.py setup with connection pooling
from web3 import Web3
from web3.middleware import geth_poa_middleware
from typing import Annotated
import asyncio

class BlockchainService:
    def __init__(self):
        self.rpc_providers = {
            'ethereum': [
                Web3(Web3.HTTPProvider(url)) 
                for url in settings.ETH_RPC_URLS
            ],
            'base': [
                Web3(Web3.HTTPProvider(url)) 
                for url in settings.BASE_RPC_URLS
            ],
            # Add more chains
        }
        
        # Add POA middleware for L2 chains
        for chain_name in ['base', 'arbitrum', 'polygon']:
            for w3 in self.rpc_providers[chain_name]:
                w3.middleware_onion.inject(geth_poa_middleware, layer=0)
    
    async def get_transaction_receipt(
        self,
        tx_hash: str,
        chain: str,
        max_retries: int = 10
    ) -> dict:
        """Get transaction receipt with retry logic."""
        w3 = self._get_web3_instance(chain)
        
        for attempt in range(max_retries):
            try:
                receipt = w3.eth.get_transaction_receipt(tx_hash)
                return {
                    'status': 'success' if receipt['status'] == 1 else 'failed',
                    'block_number': receipt['blockNumber'],
                    'gas_used': receipt['gasUsed'],
                }
            except Exception as e:
                if attempt == max_retries - 1:
                    raise HTTPException(
                        status_code=503,
                        detail=f"Transaction receipt not found after {max_retries} attempts"
                    )
                await asyncio.sleep(2 ** attempt)  # Exponential backoff
```

**Transaction Monitoring:**
```python
# ‚úÖ Transaction monitoring service
class TransactionMonitorService:
    async def monitor_transaction(
        self,
        tx_hash: str,
        chain: str,
        timeout: int = 300  # 5 minutes
    ) -> dict:
        """Monitor transaction until confirmed or timeout."""
        start_time = asyncio.get_event_loop().time()
        
        while True:
            elapsed = asyncio.get_event_loop().time() - start_time
            if elapsed > timeout:
                raise HTTPException(
                    status_code=408,
                    detail="Transaction monitoring timeout"
                )
            
            receipt = await self.blockchain_service.get_transaction_receipt(
                tx_hash, chain
            )
            
            if receipt['status'] in ['success', 'failed']:
                return receipt
            
            await asyncio.sleep(2)  # Poll every 2 seconds
```

---

## üìù Code Quality Standards

### Python Code Style
- **Formatter**: Black (88 char line length)
- **Linter**: Flake8 (follow `setup.cfg` rules)
- **Type checking**: MyPy (strict mode enabled)
- **Imports**: isort with black profile
- **Docstrings**: Google style for complex functions

### Type Hints
```python
# ‚úÖ Always use type hints
from typing import Annotated, Optional, List

async def get_bots(
    user_id: str,
    db: AsyncSession,
    limit: Optional[int] = None
) -> List[Bot]:
    ...

# ‚úÖ Use Annotated for dependencies
from fastapi import Depends

async def create_bot(
    request: CreateBotRequest,
    current_user: Annotated[dict, Depends(validate_jwt_and_get_user)],
    db: Annotated[AsyncSession, Depends(get_db_session)],
) -> BotResponse:
    ...
```

### Database Migrations (Alembic)
```bash
# Create migration
alembic revision --autogenerate -m "Add bot status column"

# Apply migration
alembic upgrade head

# Rollback migration
alembic downgrade -1
```

---

## üîß MCP Integration for Backend

### MCP Hub Configuration

**All MCP servers are accessed through MCP Hub** to bypass Cursor's 40-tool limit:
- **Configuration**: Individual servers in `~/.cursor/mcp-hub.json`
- **Main config**: Only `mcp-hub` in `~/.cursor/mcp.json`
- **Access**: Use MCP Hub tools (`list-all-tools`, `call-tool`) to access all servers
- **Environment variables**: Set in `.env` file (see `.cursor/MCP_ENV_VARS_ADDED.md`)

### Required MCP Servers for CryptoOrchestrator

#### Cryptocurrency & Trading
- **CoinGecko MCP**: Real-time crypto prices, market data, historical OHLCV
  - Use in services: Price data for swaps, market analysis, backtesting
  - Configuration: `docs.coingecko.com/reference/mcp-server`
- **Web3 MCP** (strangelove-ventures/web3-mcp): Multi-chain blockchain interactions
  - Use in services: Wallet operations, transaction status, multi-chain support
  - Configuration: `github.com/strangelove-ventures/web3-mcp`
- **DeFi Trading MCP** (edkdev/defi-trading-mcp): Portfolio analysis and trading
  - Use in services: Portfolio tracking, DEX liquidity, transaction history
  - Configuration: `lobehub.com/mcp/edkdev-defi-trading-mcp`

#### Database & Infrastructure
- **PostgreSQL MCP** (Official): Read-only database access
  - Use for: Schema inspection, query testing, data debugging
  - Configuration: `modelcontextprotocol/servers`
- **Redis MCP** (Official): Redis key-value store interaction
  - Use for: Cache management, rate limiting, session storage
  - Configuration: `redis/mcp-redis`
- **SQLite MCP**: Development database operations
  - Package: `mcp-server-sqlite` (Python)
  - Module: `mcp_server_sqlite`
  - Installation: `pip install mcp-server-sqlite`
  - Configuration: Set `SQLITE_DB_PATH` environment variable

#### Development & Documentation
- **Context7**: Get latest FastAPI, Python, SQLAlchemy, Pydantic, Web3.py documentation
- **StackOverflow**: Search for Python/FastAPI patterns and solutions
- **Brave Search**: Find best practices and security recommendations
- **Postgres/Enhanced-Postgres/SQLite**: Database operations and queries
- **Memory/Memory-Bank**: Store backend patterns and solutions
- **Filesystem**: Advanced file operations for services and routes
- **Git**: Version control for backend code
- **GitHub**: GitHub integration for issues, PRs, and repository management
- **Docker**: Container operations and Dockerfile management
- **Sentry**: Error tracking and monitoring integration
- **ArXiv**: Research papers for ML/advanced trading algorithms
  - Package: `arxiv-search-mcp` (Python)
  - Module: `arxiv_search_mcp`
  - Installation: `pip install arxiv-search-mcp`
- **AllThingsDev**: API marketplace for integrations
- **Sequential Thinking**: Complex problem-solving for backend architecture
- **Render**: Deploy backend services to Render
- **Stripe MCP**: Payment processing integration
- **Postman MCP**: API testing and validation

### When to Use MCPs

**CoinGecko MCP (Cryptocurrency Prices):**
- "Get current BTC price for swap calculations"
- "Get historical ETH data for backtesting"
- "List trending tokens for market analysis"
- "Get market cap data for portfolio valuation"
- Use in services: Price data for DEX swaps, portfolio valuation

**Web3 MCP (Blockchain Operations):**
- "Check wallet balance on Ethereum"
- "Get transaction status on Base"
- "Query smart contract on Arbitrum"
- "Get gas prices for multiple chains"
- Use in services: Wallet operations, transaction monitoring, multi-chain support

**DeFi Trading MCP (Trading Features):**
- "Analyze portfolio performance across chains"
- "Track DEX liquidity for token pairs"
- "Monitor transaction history"
- "Get market data intelligence"
- Use in services: Portfolio analysis, DEX integration, trading features

**Context7 (Documentation):**
- "Get latest FastAPI async dependency injection patterns"
- "Find SQLAlchemy 2.0 async query patterns"
- "Get Pydantic v2 validation examples"
- "FastAPI WebSocket patterns"
- "Alembic migration best practices"
- "Celery async task patterns"
- "Web3.py multi-chain patterns"
- "DEX aggregator integration (0x, OKX, Rubic)"
- "Blockchain RPC error handling"

**StackOverflow (Patterns & Solutions):**
- Search for Python/FastAPI error messages
- Find common patterns and solutions
- Check for known issues with libraries
- Troubleshoot async/await problems
- Debug SQLAlchemy query issues
- "Blockchain transaction errors"
- "DEX aggregator integration issues"
- "Web3.py connection problems"
- "Multi-chain wallet management"

**Brave Search (Best Practices):**
- "FastAPI async best practices 2024"
- "Cryptocurrency exchange API security practices"
- "SQLAlchemy async connection pooling"
- "Python type hints advanced patterns"
- "API rate limiting strategies"
- "Database migration safety practices"
- "Crypto trading platform security 2025"
- "DEX aggregator best practices"
- "Multi-chain wallet architecture"
- "Blockchain RPC error handling strategies"

**Postgres/Enhanced-Postgres/SQLite (Database):**
- Run SQL queries for debugging
- Inspect database schema
- Check data integrity
- Test migrations before applying
- Analyze query performance
- Manage database connections
- Inspect wallet table schema
- Check transaction history data
- **SQLite MCP**: Requires `mcp-server-sqlite` package, use module `mcp_server_sqlite`
- **Postgres MCP**: Requires `DATABASE_URL` environment variable

**Memory/Memory-Bank (Knowledge Storage):**
- Store custom service patterns
- Save complex query solutions
- Remember architecture decisions
- Document backend solutions
- Track security patterns

**Filesystem:**
- Bulk file operations
- Service/repository scaffolding
- File structure management
- Search across codebase

**Git/GitHub:**
- Create branches for backend features
- Review PRs and issues
- Commit backend changes
- Collaborate on backend code
- Track changes in migrations

**Docker:**
- Build and test containers
- Manage docker-compose files
- Debug container issues
- Optimize Dockerfile

**Sentry:**
- Configure error tracking
- Set up monitoring
- Analyze error patterns
- Debug production issues

**ArXiv (Research):**
- Find ML trading algorithms
- Research market prediction models
- Explore sentiment analysis techniques
- Study risk management papers
- **ArXiv MCP**: Requires `arxiv-search-mcp` package, use module `arxiv_search_mcp`

**AllThingsDev:**
- Browse API marketplace
- Find integration APIs
- Compare API offerings
- Get API documentation

### Example Usage

**Crypto-Specific Examples:**
```python
# Use CoinGecko MCP for price data in services
price = await get_coin_gecko_price('ethereum')
# Use Web3 MCP for blockchain operations
balance = await get_web3_balance(address, 'ethereum')
# Use DeFi Trading MCP for portfolio analysis
portfolio = await get_defi_trading_portfolio(address)
```

**Development Examples:**
```python
# Use Context7 to get latest FastAPI patterns
# Use StackOverflow to search for "FastAPI async dependency injection"
# Use Brave Search for "crypto trading platform security best practices"
# Use Postgres MCP to inspect database schema
# Use Memory-Bank to store a custom repository pattern
# Use ArXiv to research "cryptocurrency market prediction ML"
# Use Sentry MCP to configure error tracking
# Use Web3 MCP to test blockchain interactions
# Use CoinGecko MCP to validate price data sources
```

---

## ü§ñ Backend-Specific Agent Behavior

### Default Mode: AUTONOMOUS OPERATION

**The agent operates in AUTONOMOUS MODE for all backend tasks**, meaning:

- ‚úÖ **Automatically uses all tools** - MCP tools, codebase search, database tools - NO ASKING
- ‚úÖ **Automatically researches** - Intelligence system, codebase patterns, external docs - NO ASKING
- ‚úÖ **Automatically plans** - Architecture, patterns, risks - NO ASKING
- ‚úÖ **Automatically implements** - Routes, services, repositories, tests - NO ASKING
- ‚úÖ **Automatically fixes issues** - TypeScript errors, lint errors, test failures - NO ASKING
- ‚úÖ **Automatically verifies** - Runs tests, checks errors, validates fixes - NO ASKING

**The agent only asks when requirements are genuinely ambiguous (rare cases).**

### Mandatory Intelligence System Usage (AUTOMATIC)

**REQUIRED**: The agent MUST automatically use the intelligence system for EVERY backend task - NO EXCEPTIONS.

**Before ANY backend task, AUTOMATICALLY (MANDATORY):**
1. ‚úÖ **AUTOMATICALLY** Read `.cursor/extracted-patterns.md` - Find FastAPI Route Pattern (85+ files), Service Layer Pattern (100+ files), Repository Pattern (20+ files)
2. ‚úÖ **AUTOMATICALLY** Read `.cursor/knowledge-base.md` - Check for backend patterns and solutions
3. ‚úÖ **AUTOMATICALLY** Read `.cursor/quick-reference.md` - Fast lookup for backend patterns
4. ‚úÖ **AUTOMATICALLY** Use Memory-Bank: `read_global_memory_bank({ docs: ".cursor", path: "patterns/fastapi-route.json" })` - Retrieve stored patterns
5. ‚úÖ **AUTOMATICALLY** Check `.cursor/predictive-suggestions.md` - Get backend-specific predictions
6. ‚úÖ **AUTOMATICALLY** Apply heuristics: Read `.cursor/intelligence-heuristics.md` - Backend decision rules

**The agent does NOT ask** - it automatically uses the intelligence system before every backend task.

**When creating routes:**
- ‚úÖ Match FastAPI Route Pattern from `.cursor/extracted-patterns.md`
- ‚úÖ Use `Annotated[Type, Depends()]` for dependencies
- ‚úÖ Use `_get_user_id()` helper for user ID extraction
- ‚úÖ Add `@cached` decorator for endpoint-level caching
- ‚úÖ Use `cache_query_result` for query-level caching

**When creating services:**
- ‚úÖ Match Service Layer Pattern from `.cursor/extracted-patterns.md`
- ‚úÖ Keep services stateless (preferred)
- ‚úÖ Delegate data access to repositories
- ‚úÖ Inject repository in `__init__`

**When creating repositories:**
- ‚úÖ Match Repository Pattern from `.cursor/extracted-patterns.md`
- ‚úÖ Use async database operations
- ‚úÖ Use eager loading to prevent N+1 queries
- ‚úÖ Handle transactions properly

### Automatic Codebase Search (MANDATORY)

**The agent AUTOMATICALLY searches the codebase before implementing - NO ASKING:**

- ‚úÖ **AUTOMATICALLY** Search for similar endpoints before creating routes
- ‚úÖ **AUTOMATICALLY** Check existing service patterns before creating services
- ‚úÖ **AUTOMATICALLY** Search for existing models before database changes
- ‚úÖ **AUTOMATICALLY** Check for similar functionality before adding dependencies
- ‚úÖ **AUTOMATICALLY** Match patterns from `.cursor/extracted-patterns.md`

**Automatic search queries:**
- ‚úÖ "How are database sessions managed in routes?" - AUTOMATICALLY search
- ‚úÖ "Where are exchange API calls made?" - AUTOMATICALLY search
- ‚úÖ "How is authentication implemented in routes?" - AUTOMATICALLY search
- ‚úÖ "What error handling patterns are used?" - AUTOMATICALLY search
- ‚úÖ "How are blockchain RPC calls handled?" - AUTOMATICALLY search
- ‚úÖ "Where are DEX aggregator services implemented?" - AUTOMATICALLY search

**The agent does NOT ask** - it automatically searches before implementing.

### Automatic Backend Code Generation

**The agent AUTOMATICALLY generates complete, production-ready code - NO ASKING:**

- ‚úÖ **AUTOMATICALLY** Include: Type hints, error handling, logging, tests
- ‚úÖ **AUTOMATICALLY** Follow Route pattern: Request model ‚Üí Service call ‚Üí Response model ‚Üí Error handling
- ‚úÖ **AUTOMATICALLY** Follow Service pattern: Validate ‚Üí Transform ‚Üí Repository call ‚Üí Return
- ‚úÖ **AUTOMATICALLY** Follow Repository pattern: Async query ‚Üí Result mapping ‚Üí Return typed result
- ‚úÖ **AUTOMATICALLY** Write tests: Success case + validation error + permission error + edge cases
- ‚úÖ **AUTOMATICALLY** Match extracted patterns from `.cursor/extracted-patterns.md`
- ‚úÖ **AUTOMATICALLY** Apply predictive suggestions from `.cursor/predictive-suggestions.md`

**The agent does NOT ask** - it automatically generates complete code following all patterns.

### Automatic Backend Code Verification

**The agent AUTOMATICALLY verifies backend code before completion - NO ASKING:**

**Automatic verification checklist (runs automatically):**
- ‚úÖ All async functions use `async def` and `await` properly - AUTOMATICALLY verify
- ‚úÖ Database sessions use `yield` for proper cleanup - AUTOMATICALLY verify
- ‚úÖ All inputs validated with Pydantic models - AUTOMATICALLY verify
- ‚úÖ Errors logged with context (user_id, bot_id, etc.) - AUTOMATICALLY verify
- ‚úÖ No sensitive data in logs (use LogSanitizer) - AUTOMATICALLY verify
- ‚úÖ Redis availability checked before cache operations - AUTOMATICALLY verify
- ‚úÖ Trading modes normalized ("live" ‚Üí "real") - AUTOMATICALLY verify
- ‚úÖ Type hints on all functions (mypy strict mode) - AUTOMATICALLY verify
- ‚úÖ Tests cover success and error paths - AUTOMATICALLY verify
- ‚úÖ Database queries use indexes (check for N+1 queries) - AUTOMATICALLY verify
- ‚úÖ DEX aggregator fallback logic implemented - AUTOMATICALLY verify
- ‚úÖ Multi-chain wallet operations handle RPC failures - AUTOMATICALLY verify
- ‚úÖ Blockchain transactions have proper error handling - AUTOMATICALLY verify
- ‚úÖ Gas fee estimation includes priority levels - AUTOMATICALLY verify
- ‚úÖ Price impact warnings shown for high-impact swaps - AUTOMATICALLY verify

**The agent does NOT ask** - it automatically verifies all checks before completion.

### Automatic Backend Debugging

**The agent AUTOMATICALLY debugs issues without asking - NO ASKING:**

1. ‚úÖ **AUTOMATICALLY** Check logs: `logs/fastapi.log` for error details
2. ‚úÖ **AUTOMATICALLY** Test endpoints: Use FastAPI docs at `http://localhost:8000/docs`
3. ‚úÖ **AUTOMATICALLY** Use Postgres/SQLite MCP to inspect schema and test queries
4. ‚úÖ **AUTOMATICALLY** Check for missing `await` or blocking operations
5. ‚úÖ **AUTOMATICALLY** Verify dependency injection setup in `main.py`
6. ‚úÖ **AUTOMATICALLY** Check Alembic migration history and test migrations
7. ‚úÖ **AUTOMATICALLY** Run `pytest` to identify failing tests
8. ‚úÖ **AUTOMATICALLY** Run `mypy` to identify type errors
9. ‚úÖ **AUTOMATICALLY** Use codebase search to find similar issues and solutions

**The agent does NOT ask** - it automatically debugs and fixes issues.

---

## üö® Critical Backend Rules

1. **Always use async/await** for I/O operations (database, HTTP, Redis, blockchain RPC)
2. **Use dependency injection with Annotated** - don't instantiate services directly, use `Depends()` with `Annotated` type hints
3. **Validate all inputs** with Pydantic models
4. **Handle errors gracefully** - use HTTPException, log with context
5. **Never log sensitive data** - use LogSanitizer middleware (API keys, private keys, passwords)
6. **Check Redis availability** before using cache features
7. **Normalize trading modes** - "live" ‚Üí "real" for backend
8. **Use yield in dependencies** for resources requiring cleanup (DB sessions, blockchain connections)
9. **Test routes and services** - aim for 85%+ coverage (enforced in CI)
10. **Use type hints** - enable mypy strict mode, use `Annotated` for dependencies
11. **Search codebase first** - find existing patterns before creating new code
12. **Prevent N+1 queries** - use eager loading (`selectinload`/`joinedload`) from `QueryOptimizer`
13. **Implement pagination** - use `QueryOptimizer.paginate_query()` for all list endpoints
14. **Use multi-level caching** - leverage `MultiLevelCache` for memory + Redis caching
15. **Optimize API responses** - use `ResponseOptimizer` for pagination, field selection, null filtering
16. **Validate permissions** - always check user ownership before operations
17. **Use connection pooling** - configure pool settings from `Settings` class, enable `pool_pre_ping`
18. **Handle exchange errors** - implement retries and circuit breakers
19. **Implement DEX aggregator fallback** - use multiple aggregators (0x, OKX, Rubic) with fallback logic
20. **Handle blockchain RPC errors** - implement retries with exponential backoff
21. **Encrypt wallet private keys** - always encrypt at rest (AES-256), never log
22. **Validate price impact** - warn users if price impact exceeds threshold (>1%)
23. **Monitor transaction status** - poll blockchain until confirmed or timeout
24. **Add database indexes** - create composite indexes for common query patterns (see `optimize_query_indexes.py`)
25. **Use eager loading in repositories** - add `selectinload`/`joinedload` options to prevent N+1 queries
26. **Test migrations** - always test migrations in CI/CD before deploying
27. **Automate backups** - schedule daily backups with retention policies
28. **Document recovery procedures** - maintain disaster recovery runbook
29. **Monitor backup health** - verify backups regularly, alert on failures
30. **Use test factories** - leverage `server_fastapi/tests/utils/test_factories.py` for test data

---

## üìö Reference Files

- **Project Rules**: `.cursor/rules/cursorprojectrules.mdc`
- **Main App**: `server_fastapi/main.py`
- **Settings**: `server_fastapi/config/settings.py`
- **Requirements**: `requirements.txt`
- **Test Config**: `pytest.ini`

---

**Remember**: Backend code should be:
- **Async** (async/await for I/O)
- **Type-safe** (type hints, mypy strict)
- **Secure** (validate inputs, sanitize logs, check permissions)
- **Tested** (unit + integration tests)
- **Performant** (connection pooling, caching, rate limiting)
