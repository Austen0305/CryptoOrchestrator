---
alwaysApply: true
description: "Frontend development rules for CryptoOrchestrator - React (legacy) and SvelteKit (new)"
---
# CryptoOrchestrator - Frontend Development Rules

> **Current Date**: December 11, 2025  
> **Last Updated**: 2025-12-11

You are an expert frontend software engineer specializing in this production-ready cryptocurrency trading automation platform. Follow these rules when working on frontend code.

> **Note**: The project uses the optimized React stack for maximum performance and production readiness.

## üé® Frontend Stack & Architecture

### Production Stack (React - Active)
- **Framework**: React 18+ with TypeScript (strict mode enabled)
- **Build System**: Vite with advanced manual code splitting
- **State Management**: 
  - **Server State**: TanStack Query (React Query) v5+ with request deduplication
  - **UI State**: React useState/useReducer
  - **Global State**: Zustand (when needed)
  - **Form State**: React Hook Form with Zod validation
- **UI Components**: shadcn/ui (Radix UI primitives)
- **Styling**: Tailwind CSS with dark mode support and custom animations
- **Routing**: React Router (if used) or component-based routing
- **Desktop**: Electron wrapper with Python runtime bundling and auto-updater
- **Mobile**: React Native/Expo with push notifications, offline mode, and biometric auth
- **PWA**: Vite PWA plugin for offline support with 55+ precached entries
- **Testing**: Vitest for unit tests, Playwright for E2E (cross-browser: Chromium, Firefox, WebKit)


### Directory Structure
```
client/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/          # UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/             # shadcn/ui base components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [feature]/      # Feature-specific components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoadingSkeleton.tsx  # Loading states with variants
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PageTransition.tsx    # Page transition animations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MobileMenu.tsx        # Mobile navigation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AccessibilityProvider.tsx  # Accessibility features
‚îÇ   ‚îú‚îÄ‚îÄ hooks/               # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useApi.ts       # React Query hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useFormValidation.ts  # Form validation with debouncing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useVirtualScroll.ts   # Virtual scrolling for large lists
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useIntersectionObserver.ts  # Lazy loading hook
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [feature].ts    # Feature hooks
‚îÇ   ‚îú‚îÄ‚îÄ lib/                 # Utilities & API clients
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts          # API function definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queryClient.ts  # React Query setup with request deduplication
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts        # Helper functions
‚îÇ   ‚îú‚îÄ‚îÄ utils/               # Performance & optimization utilities
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ performance.ts  # Debounce, throttle, deduplication, batching
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ imageOptimization.ts  # WebP/AVIF, lazy loading, srcset
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ accessibility.ts  # Accessibility utilities (focus trap, announcements)
‚îÇ   ‚îú‚îÄ‚îÄ pages/               # Page components
‚îÇ   ‚îú‚îÄ‚îÄ contexts/            # React contexts
‚îÇ   ‚îú‚îÄ‚îÄ locales/             # i18n translations
‚îÇ   ‚îî‚îÄ‚îÄ test/                # Test utilities
‚îú‚îÄ‚îÄ public/                  # Static assets
‚îú‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ vite.config.ts          # Vite config with advanced code splitting
```

### Path Aliases
- `@/*` ‚Üí `client/src/*`
- `@shared/*` ‚Üí `shared/*`

---

## üîÑ React Query (TanStack Query) Patterns

### Query Key Structure
```typescript
// ‚úÖ Good: Hierarchical query keys
['bots']                    // All bots
['bots', botId]            // Single bot
['bots', botId, 'trades']  // Bot trades
['trades', { botId, mode }] // Trades with filters

// ‚ùå Bad: Flat or inconsistent keys
['bot-list'] // Don't use descriptive strings
['bot', id]  // Inconsistent with ['bots', id]
```

### Query Hooks Pattern
```typescript
// client/src/hooks/useApi.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { botApi } from '@/lib/api';

export const useBots = () => {
  return useQuery({
    queryKey: ['bots'],
    queryFn: () => botApi.getBots(),
    staleTime: 30000, // 30 seconds
    refetchInterval: false, // Disable polling when WebSocket available
  });
};

export const useBot = (botId: string) => {
  return useQuery({
    queryKey: ['bots', botId],
    queryFn: () => botApi.getBot(botId),
    enabled: !!botId, // Only fetch if botId exists
    staleTime: 30000,
  });
};

export const useCreateBot = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (bot: InsertBotConfig) => botApi.createBot(bot),
    onSuccess: () => {
      // Invalidate all bots queries (prefix match by default)
      queryClient.invalidateQueries({ queryKey: ['bots'] });
    },
  });
};
```

### Query Invalidation Patterns
```typescript
// ‚úÖ Prefix matching (default) - invalidates all ['bots', ...] queries
queryClient.invalidateQueries({ queryKey: ['bots'] });

// ‚úÖ Exact matching - only invalidates exact ['bots'] key
queryClient.invalidateQueries({ queryKey: ['bots'], exact: true });

// ‚úÖ Predicate function - complex invalidation logic
queryClient.invalidateQueries({
  predicate: (query) => 
    query.queryKey[0] === 'bots' && 
    query.state.data?.version >= 10
});

// ‚úÖ Refetch control
queryClient.invalidateQueries({
  queryKey: ['bots'],
  refetchType: 'active' | 'inactive' | 'all' | 'none'
});
```

### Polling vs WebSocket
- **Use polling** for resources that need periodic updates (5000ms interval)
- **Disable polling** when WebSocket is connected (real-time updates)
- **Example**:
  ```typescript
  const { isConnected } = useWebSocket();
  const { data } = useQuery({
    queryKey: ['bot-status', botId],
    queryFn: () => botApi.getBotStatus(botId),
    refetchInterval: isConnected ? false : 5000,
  });
  ```

---

## üì° API Client Patterns

### API Function Definition
```typescript
// client/src/lib/api.ts
import { apiRequest } from './queryClient';
import type { BotConfig, InsertBotConfig } from '@shared/schema';

export const botApi = {
  getBots: () => apiRequest("/api/bots", { method: "GET" }),
  
  createBot: (bot: InsertBotConfig) => 
    apiRequest("/api/bots", { method: "POST", body: bot }),
  
  updateBot: (id: string, updates: Partial<BotConfig>) =>
    apiRequest(`/api/bots/${id}`, { method: "PATCH", body: updates }),
};

// Trading mode normalization: "live" ‚Üí "real" for backend
export const portfolioApi = {
  getPortfolio: (mode: "paper" | "real" | "live") => {
    const normalizedMode = mode === "live" ? "real" : mode;
    return apiRequest(`/api/portfolio?mode=${normalizedMode}`, { method: "GET" });
  },
};
```

### Error Handling
```typescript
// client/src/lib/queryClient.ts - API request wrapper
export async function apiRequest<T>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  const token = localStorage.getItem('token');
  
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
      ...options.headers,
    },
  });

  if (!response.ok) {
    if (response.status === 401) {
      // Handle auth expiration
      localStorage.removeItem('token');
      window.dispatchEvent(new CustomEvent('auth:expired'));
      throw new Error('Authentication expired');
    }
    const error = await response.json().catch(() => ({ message: 'Unknown error' }));
    throw new Error(error.message || `HTTP ${response.status}`);
  }

  return response.json();
}
```

---

## üß© Component Patterns

### Component Structure
```typescript
// ‚úÖ Good: TypeScript interface, proper typing, error handling
import { useBots, useCreateBot } from '@/hooks/useApi';
import { Button } from '@/components/ui/button';
import { LoadingSkeleton } from '@/components/LoadingSkeleton';
import { ErrorBoundary } from '@/components/ErrorBoundary';

interface BotListProps {
  userId?: string;
}

export function BotList({ userId }: BotListProps) {
  const { data: bots, isLoading, error } = useBots();
  const createBot = useCreateBot();

  if (isLoading) return <LoadingSkeleton />;
  if (error) return <ErrorFallback error={error} />;

  return (
    <ErrorBoundary>
      <div>
        {bots?.map(bot => <BotCard key={bot.id} bot={bot} />)}
      </div>
    </ErrorBoundary>
  );
}
```

### Form Patterns with React Hook Form + Zod
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const createBotSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  strategy: z.enum(['momentum', 'mean_reversion']),
});

type CreateBotForm = z.infer<typeof createBotSchema>;

export function BotCreator() {
  const createBot = useCreateBot();
  
  const form = useForm<CreateBotForm>({
    resolver: zodResolver(createBotSchema),
    defaultValues: { name: '', strategy: 'momentum' },
  });

  const onSubmit = (data: CreateBotForm) => {
    createBot.mutate(data, {
      onSuccess: () => form.reset(),
    });
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields */}
    </form>
  );
}
```

### Loading & Error States
```typescript
// ‚úÖ Use LoadingSkeleton component for loading states
import { LoadingSkeleton } from '@/components/LoadingSkeleton';

if (isLoading) return <LoadingSkeleton />;

// ‚úÖ Use ErrorBoundary for component errors
import { ErrorBoundary } from '@/components/ErrorBoundary';

<ErrorBoundary
  fallback={<ErrorFallback />}
  onError={(error, errorInfo) => {
    logger.error('Component error', { error, errorInfo });
  }}
>
  <YourComponent />
</ErrorBoundary>
```

---

## üéØ State Management Guidelines

### Server State ‚Üí React Query
- All API data should use React Query
- Never duplicate server state in component state
- Use React Query cache as source of truth

### UI State ‚Üí useState/useReducer
- Form inputs, modals, dropdowns, etc.
- Keep local to component when possible

### Global UI State ‚Üí Zustand (if needed)
```typescript
// Only for complex shared UI state (theme, preferences)
import { create } from 'zustand';

interface ThemeStore {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

export const useThemeStore = create<ThemeStore>((set) => ({
  theme: 'dark',
  toggleTheme: () => set((state) => ({ 
    theme: state.theme === 'light' ? 'dark' : 'light' 
  })),
}));
```

---

## üß™ Testing Patterns

### Complete E2E Testing Infrastructure

**NEW**: Comprehensive end-to-end testing infrastructure with automated service management.

#### Unified Test Runner
- **Command**: `npm run test:e2e:complete`
- **Script**: `scripts/test-e2e-complete.js`
- **Features**:
  - Validates environment before tests
  - Starts all services automatically
  - Runs Playwright E2E tests
  - Runs Puppeteer critical flow tests
  - Generates combined reports
  - Cleans up services

#### Puppeteer Testing
- **Configuration**: `puppeteer.config.js` - Centralized browser options
- **Test Helper**: `tests/puppeteer/test-helper.js`
  - Retry logic with exponential backoff
  - Safe element operations (click, type, navigate)
  - Screenshot handling
  - Consistent result format
- **Test Files**: `tests/puppeteer/*.js`
  - `auth-flow.js` - Authentication flow testing
  - `bot-management.js` - Bot CRUD operations
  - `dex-trading.js` - DEX swap testing
  - `wallet-operations.js` - Wallet management
- **Pattern**:
  ```javascript
  const { safeNavigate, safeClick, createTestResults, finalizeResults, config } = require('./test-helper');
  
  async function testFeature() {
    const browser = await puppeteer.launch(config.launch);
    const page = await browser.newPage();
    const results = createTestResults();
    
    try {
      await safeNavigate(page, `${BASE_URL}/feature`);
      // Test logic
      results.passed.push('Feature works');
    } catch (error) {
      results.failed.push(`Error: ${error.message}`);
    } finally {
      await browser.close();
      finalizeResults(results);
    }
  }
  ```

#### Test Reporting
- **Report Generator**: `scripts/generate-test-report.js`
  - Combines Playwright and Puppeteer results
  - Generates HTML and JSON reports
  - Location: `test-results/combined-report.html`

### Component Tests (Vitest + Testing Library)
```typescript
// client/src/components/__tests__/BotList.test.tsx
import { render, screen } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BotList } from '../BotList';

const queryClient = new QueryClient({
  defaultOptions: { queries: { retry: false } },
});

test('renders bot list', async () => {
  render(
    <QueryClientProvider client={queryClient}>
      <BotList />
    </QueryClientProvider>
  );
  
  expect(await screen.findByText('Test Bot')).toBeInTheDocument();
});
```

### Hook Tests
```typescript
// client/src/hooks/__tests__/useApi.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useBots } from '../useApi';

test('fetches bots', async () => {
  const queryClient = new QueryClient();
  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );

  const { result } = renderHook(() => useBots(), { wrapper });

  await waitFor(() => expect(result.current.isSuccess).toBe(true));
  expect(result.current.data).toHaveLength(1);
});
```

### E2E Tests (Playwright)
```typescript
// tests/e2e/bots.spec.ts
import { test, expect } from '@playwright/test';

test('should create bot successfully', async ({ page }) => {
  await page.goto('/bots');
  await page.getByTestId('create-bot-btn').click();
  await page.fill('input[name="name"]', 'Test Bot');
  await page.selectOption('select[name="strategy"]', 'momentum');
  await page.click('button[type="submit"]');
  
  await expect(page.locator('text=Test Bot')).toBeVisible();
  await expect(page).toHaveURL(/\/bots/);
});
```

### NPM Scripts
- `test:e2e:complete` - Run complete E2E test suite
- `test:puppeteer` - Run Puppeteer tests only
- `start:all` - Start all services
- `validate:env` - Validate environment
- `check:services` - Check service health

---

## üé® Styling Guidelines

### Tailwind CSS
- Use Tailwind utility classes (no custom CSS unless necessary)
- Dark mode: Use `dark:` prefix for dark mode styles
- Responsive: Use breakpoint prefixes (`sm:`, `md:`, `lg:`)
- Custom theme: Extend in `tailwind.config.ts`

### shadcn/ui Components
- Components in `client/src/components/ui/` (Radix UI primitives)
- Use existing components: `Button`, `Card`, `Dialog`, `Select`, etc.
- Customize via Tailwind classes, not by modifying base components

---

## ‚ö° Performance Optimization

### Code Splitting
- Vite automatically splits vendor chunks (see `vite.config.ts`)
- Manual chunks: React, React Query, Charts, Radix UI, Icons
- **Advanced chunk splitting**: Radix UI split into overlays/forms/core, Web3 libraries, date-utils, forms, validation
- Lazy load routes and heavy components:
 ```typescript
 const HeavyComponent = lazy(() => import('./HeavyComponent'));
 ```

### React Optimization
- Use `React.memo` for expensive components (BotCreator, OrderEntryPanel, EmptyState, etc.)
- Use `useMemo` for expensive computations
- Use `useCallback` for stable function references
- Debounce/throttle API calls in search/filters using `@/utils/performance`
- **Request Deduplication**: Prevents duplicate API calls (implemented in `queryClient.ts`)

### Performance Utilities
```typescript
// ‚úÖ Use performance utilities from @/utils/performance
import { debounce, throttle, deduplicateRequest, batchOperations } from '@/utils/performance';

// Debounce search input
const debouncedSearch = debounce((query: string) => {
  searchApi(query);
}, 300);

// Throttle scroll events
const throttledScroll = throttle(() => {
  handleScroll();
}, 100);

// Deduplicate API requests
const result = await deduplicateRequest('key', () => apiRequest('/api/data'));
```

### Image Optimization
```typescript
// ‚úÖ Use image optimization utilities
import { generateSrcSet, getOptimizedImageUrl, useLazyImage } from '@/utils/imageOptimization';

// Generate responsive srcset
const srcset = generateSrcSet(imageUrl, [320, 640, 960, 1280]);

// Lazy load images
const { ref, src, isLoaded } = useLazyImage(imageUrl, placeholder);
```

### Virtual Scrolling
```typescript
// ‚úÖ Use virtual scrolling for large lists
import { useVirtualScroll } from '@/hooks/useVirtualScroll';

const { virtualItems, totalHeight, scrollToIndex } = useVirtualScroll({
  items: largeList,
  itemHeight: 50,
  containerHeight: 400,
});
```

### Bundle Size
- Chunk size warning limit: 1MB (configured in `vite.config.ts`)
- Monitor bundle with `npm run build` (Vite visualizer)
- Remove unused dependencies
- **TensorFlow excluded** from optimizeDeps for lazy loading

---

## üîß TypeScript Strict Mode

### Strict Patterns
```typescript
// ‚úÖ Use strictNullChecks
const bot: BotConfig | undefined = data;
if (bot) {
  // TypeScript knows bot is defined here
  console.log(bot.name);
}

// ‚úÖ Avoid `any` - use `unknown` for truly unknown types
function handleError(error: unknown) {
  if (error instanceof Error) {
    console.error(error.message);
  }
}

// ‚úÖ Use type predicates for type narrowing
function isBotConfig(value: unknown): value is BotConfig {
  return typeof value === 'object' && value !== null && 'id' in value;
}

// ‚úÖ Use const assertions for enum-like patterns
const TradingMode = {
  PAPER: 'paper',
  REAL: 'real',
} as const;

type TradingMode = typeof TradingMode[keyof typeof TradingMode];
```

---

## üé® UI/UX Patterns

### Loading States
```typescript
// ‚úÖ Use LoadingSkeleton with variants
import { LoadingSkeleton, FormSkeleton, ListSkeleton } from '@/components/LoadingSkeleton';

// Default skeleton
<LoadingSkeleton variant="card" />

// Form skeleton
<FormSkeleton fields={4} />

// List skeleton
<ListSkeleton items={5} />
```

### Form Validation
```typescript
// ‚úÖ Use useFormValidation hook for real-time validation
import { useFormValidation, validationRules } from '@/hooks/useFormValidation';

const { values, errors, handleChange, handleBlur, isValid } = useFormValidation(
  initialValues,
  {
    name: [validationRules.required(), validationRules.minLength(3)],
    email: [validationRules.required(), validationRules.email()],
  },
  { debounceMs: 300 }
);
```

### Page Transitions
```typescript
// ‚úÖ Use PageTransition for smooth page changes
import { PageTransition, AnimatedContainer } from '@/components/PageTransition';

<PageTransition variant="fade" duration={300}>
  <YourPageContent />
</PageTransition>

<AnimatedContainer animation="fade-in-up" delay={100}>
  <YourComponent />
</AnimatedContainer>
```

### Accessibility
```typescript
// ‚úÖ Use accessibility utilities
import { trapFocus, announceToScreenReader, getFocusableElements } from '@/utils/accessibility';

// Trap focus in modal
const cleanup = trapFocus(modalRef.current);

// Announce to screen readers
announceToScreenReader('Bot created successfully', 'polite');
```

### Mobile Optimization
```typescript
// ‚úÖ Ensure minimum touch targets (44x44px)
<Button className="min-h-[44px] min-w-[44px] touch-manipulation">
  Click me
</Button>

// Use safe area insets for mobile
<div className="safe-area-inset-bottom">
  Mobile content
</div>
```

## üêõ Frontend Debugging

### Browser Console
- Check JavaScript errors, React warnings
- Monitor network requests (Network tab)
- Inspect React Query cache: `window.__REACT_QUERY_STATE__ = queryClient.getQueryCache()`

### React DevTools
- Inspect component tree, hooks, state
- Profile performance (React DevTools Profiler)
- Check React Query DevTools for cache state

### Common Issues

**Component not re-rendering:**
```typescript
// Check if props/state actually changed
console.log('Props:', props);
console.log('State:', state);
// Use React DevTools Profiler
```

**API call failing:**
```typescript
// Check Network tab: URL, headers, response
// Verify auth token in request headers
apiRequest('/api/bots').catch(err => {
  console.error('API Error:', err);
});
```

**React Query cache stale:**
```typescript
// Check React Query DevTools
// Or force refetch:
queryClient.invalidateQueries({ queryKey: ['bots'] });
```

---

## üîó Web3 Wallet Integration Patterns

### Wallet Connection (MetaMask, WalletConnect, Coinbase Wallet)

```typescript
// ‚úÖ Web3 wallet connection hook
import { useAccount, useConnect, useDisconnect } from 'wagmi';
import { MetaMaskConnector, WalletConnectConnector } from 'wagmi/connectors';

export function useWalletConnection() {
  const { address, isConnected } = useAccount();
  const { connect, connectors } = useConnect();
  const { disconnect } = useDisconnect();

  const connectMetaMask = () => {
    connect({ connector: connectors.find(c => c.id === 'metaMask') });
  };

  const connectWalletConnect = () => {
    connect({ connector: connectors.find(c => c.id === 'walletConnect') });
  };

  return {
    address,
    isConnected,
    connectMetaMask,
    connectWalletConnect,
    disconnect,
  };
}
```

### Multi-Chain Wallet Support

```typescript
// ‚úÖ Multi-chain wallet hook
import { useNetwork, useSwitchNetwork } from 'wagmi';
import { mainnet, base, arbitrum, polygon } from 'wagmi/chains';

export function useMultiChainWallet() {
  const { chain } = useNetwork();
  const { switchNetwork } = useSwitchNetwork();

  const supportedChains = [mainnet, base, arbitrum, polygon];

  const switchToChain = (chainId: number) => {
    switchNetwork?.(chainId);
  };

  return {
    currentChain: chain,
    supportedChains,
    switchToChain,
  };
}
```

### Wallet Balance Display

```typescript
// ‚úÖ Wallet balance hook with CoinGecko price data
import { useBalance } from 'wagmi';
import { useQuery } from '@tanstack/react-query';

export function useWalletBalance(address: string, chainId: number) {
  const { data: balance, isLoading } = useBalance({
    address: address as `0x${string}`,
    chainId,
  });

  // Get USD value from CoinGecko MCP or API
  const { data: price } = useQuery({
    queryKey: ['token-price', 'ethereum', chainId],
    queryFn: () => fetchCoinGeckoPrice('ethereum'),
    staleTime: 30000,
  });

  const usdValue = balance && price 
    ? parseFloat(balance.formatted) * price 
    : null;

  return {
    balance: balance?.formatted,
    symbol: balance?.symbol,
    usdValue,
    isLoading,
  };
}
```

## üîÑ DEX Trading UI Patterns

### Swap Interface Component

```typescript
// ‚úÖ DEX swap component with price impact warning
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';

interface SwapProps {
  chainId: number;
  walletAddress: string;
}

export function SwapInterface({ chainId, walletAddress }: SwapProps) {
  const [tokenIn, setTokenIn] = useState('USDC');
  const [tokenOut, setTokenOut] = useState('ETH');
  const [amount, setAmount] = useState('');

  // Get quote from backend
  const { data: quote, isLoading } = useQuery({
    queryKey: ['dex-quote', tokenIn, tokenOut, amount, chainId],
    queryFn: () => getDexQuote(tokenIn, tokenOut, amount, chainId),
    enabled: !!amount && parseFloat(amount) > 0,
  });

  const priceImpact = quote?.price_impact || 0;
  const showWarning = priceImpact > 0.01; // 1% threshold

  return (
    <div>
      <Input
        value={amount}
        onChange={(e) => setAmount(e.target.value)}
        placeholder="Amount"
      />
      {showWarning && (
        <div className="text-yellow-500">
          Warning: Price impact is {(priceImpact * 100).toFixed(2)}%
        </div>
      )}
      <Button
        onClick={() => executeSwap(quote)}
        disabled={!quote || isLoading || showWarning}
      >
        Swap
      </Button>
    </div>
  );
}
```

### Transaction Status Tracking

```typescript
// ‚úÖ Transaction status component
export function useTransactionStatus(txHash: string | null, chainId: number) {
  return useQuery({
    queryKey: ['transaction-status', txHash, chainId],
    queryFn: () => getTransactionStatus(txHash!, chainId),
    enabled: !!txHash,
    refetchInterval: (data) => {
      // Poll every 2 seconds until confirmed
      return data?.status === 'pending' ? 2000 : false;
    },
  });
}
```

## üì± Mobile App Development

### Mobile Stack
- **Framework**: React Native with Expo
- **Navigation**: React Navigation (`@react-navigation/bottom-tabs`)
- **State Management**: React Query (`@tanstack/react-query`)
- **API Client**: Axios with interceptors
- **Storage**: AsyncStorage for local data
- **Notifications**: Expo Notifications
- **Network**: NetInfo for connectivity detection
- **Biometrics**: react-native-biometrics, react-native-keychain

### Mobile Features

**Push Notifications:**
- Expo push notifications configured
- Backend subscription management
- Foreground notification handling
- Badge count management

**Offline Mode:**
- Action queuing for trades, bot actions
- Data caching with TTL
- Automatic sync when online
- Retry logic for failed actions

**Biometric Authentication:**
- Face ID, Touch ID, fingerprint support
- Secure keychain storage
- Transaction confirmation
- App unlock protection

**Screens:**
- Dashboard: Portfolio overview, bot status
- Portfolio: Multi-chain wallets, balances, positions
- Trading: Exchange and DEX trading
- Settings: Preferences, security, offline queue
- Profile: User management, password change, 2FA

### Mobile Build & Deployment

**Build Commands:**
```bash
# iOS
cd mobile && npx expo build:ios

# Android
cd mobile && npx expo build:android
```

**CI/CD**: Automated builds in `.github/workflows/mobile-build.yml`

## üîß MCP Integration for Frontend

### MCP Hub Access

**All MCP tools are accessed through MCP Hub** to bypass Cursor's 40-tool limit:
- **Configuration**: Individual servers in `~/.cursor/mcp-hub.json`, only `mcp-hub` in `mcp.json`
- **Enable**: Only `mcp-hub` in Cursor Settings > Tools & MCP (disable all individual servers)
- **Tools**: Use `list-all-tools`, `call-tool`, `get-tool-info` to access all servers
- **Example**: `call-tool(serverName: "coingecko", toolName: "get_price", toolArgs: {symbol: "BTC"})`
- **Environment Variables**: Set in `.env` file (see `.cursor/MCP_ENV_VARS_ADDED.md`)

### Available MCP Tools
- **CoinGecko MCP**: Real-time crypto prices for UI components
- **Web3 MCP**: Blockchain interactions in hooks (wallet balances, transactions)
- **DeFi Trading MCP**: Portfolio analysis and DEX liquidity data
- **Puppeteer**: Browser automation for testing and UI verification
- **Context7**: Get latest React, TypeScript, TanStack Query, Vite documentation
- **StackOverflow**: Search for React/TypeScript patterns and solutions
- **Brave Search**: Find frontend best practices and modern patterns
- **Memory/Memory-Bank**: Store frontend patterns and solutions for future reference
- **Filesystem**: Advanced file operations when working with components
- **Git**: Version control operations for frontend code
- **GitHub**: GitHub integration for issues, PRs, and repository management
- **Render**: Deploy frontend builds to Render
- **Sequential Thinking**: Complex problem-solving for frontend architecture

### When to Use MCPs

**CoinGecko MCP (Cryptocurrency Prices):**
- Get real-time token prices for display in components
- Fetch historical price data for charts
- Get market cap and volume data
- List trending tokens
- Use in hooks: `useQuery({ queryKey: ['price', 'ethereum'], queryFn: () => getCoinGeckoPrice('ethereum') })`

**Web3 MCP (Blockchain Interactions):**
- Check wallet balances in hooks
- Get transaction status
- Query smart contract data
- Get gas prices for multiple chains
- Use in hooks: `useQuery({ queryKey: ['balance', address, chainId], queryFn: () => getWeb3Balance(address, chainId) })`

**DeFi Trading MCP (Trading Features):**
- Get portfolio performance data
- Track DEX liquidity for token pairs
- Monitor transaction history
- Get market data intelligence
- Use in components: Display portfolio analytics, DEX liquidity info

**Puppeteer (Browser Automation):**
- Verify UI components render correctly
- Test user flows and interactions programmatically
- Take screenshots for visual verification
- Debug frontend issues interactively
- Automate E2E testing workflows
- Test responsive design across viewports
- Test wallet connection flows
- Verify swap UI interactions

**Context7 (Documentation):**
- "Get latest React Query invalidation patterns"
- "Find TypeScript strict mode best practices"
- "Get React 18+ hook patterns"
- "Vite build optimization techniques"
- "TanStack Query v5 migration guide"
- "shadcn/ui component patterns"
- "Web3 wallet integration hooks (wagmi)"
- "DEX UI component patterns"

**StackOverflow (Patterns & Solutions):**
- Search for React/TypeScript error messages
- Find common patterns and solutions
- Check for known issues with libraries
- Learn from community solutions
- Troubleshoot build/compilation errors
- "Web3 wallet connection issues"
- "React Query cache not updating"
- "wagmi hook patterns"

**Brave Search (Best Practices):**
- "React performance optimization 2024"
- "TypeScript strict mode patterns"
- "Frontend security best practices"
- "Accessibility best practices React"
- "Vite production optimization"
- "Web3 wallet integration best practices"
- "DEX UI/UX patterns"
- "Crypto trading platform frontend security"

**Memory/Memory-Bank (Knowledge Storage):**
- Store custom component patterns
- Save complex hook implementations
- Remember architecture decisions
- Document frontend solutions
- Store Web3 wallet integration patterns
- Save DEX UI component patterns

**Filesystem:**
- Bulk file operations
- Component scaffolding
- File structure management
- Search across codebase

**Git/GitHub:**
- Create branches for features
- Review PRs and issues
- Commit frontend changes
- Collaborate on frontend code
- **GitHub MCP**: Requires `GITHUB_TOKEN` environment variable

### Example Usage

**Crypto-Specific Examples:**
```typescript
// Use CoinGecko MCP for price data in components
const { data: price } = useQuery({
  queryKey: ['price', 'ethereum'],
  queryFn: () => getCoinGeckoPrice('ethereum'),
});

// Use Web3 MCP for wallet balance in hooks
const { data: balance } = useQuery({
  queryKey: ['balance', address, chainId],
  queryFn: () => getWeb3Balance(address, chainId),
});

// Use DeFi Trading MCP for portfolio data
const { data: portfolio } = useQuery({
  queryKey: ['portfolio', address],
  queryFn: () => getDeFiTradingPortfolio(address),
});
```

**Development Examples:**
```typescript
// Use Context7 to get latest React Query docs
// Use Puppeteer to test wallet connection flow and take screenshots
// Use StackOverflow to search for "wagmi wallet connection issues"
// Use Memory-Bank to store a custom Web3 hook pattern
// Use Brave Search for "Web3 wallet integration React 2025"
```

---

## üìù Code Quality Standards

### TypeScript
- **Formatter**: Prettier (follow `.prettierrc.json`)
- **Linter**: ESLint (follow `.eslintrc.json`)
- **Strict mode**: All strict flags enabled (see `tsconfig.json`)
- **No `any`**: Use `unknown` for truly unknown types

### ‚ö†Ô∏è TypeScript Execution Tools - CRITICAL RULES

**tsx (TypeScript Execute) - SCRIPTS ONLY**:
- ‚ùå **NEVER** use `tsx` to run React components or frontend code
- ‚ùå **NEVER** use `tsx` to run `client/src/main.tsx` or any React app files
- ‚ùå **NEVER** use `tsx` for Vite dev server or build processes
- ‚úÖ **ONLY** use `tsx` for standalone utility scripts in `scripts/` directory
- ‚úÖ **ONLY** use `tsx` for one-off scripts, build tools, or data processing

**Correct Commands**:
- ‚úÖ Frontend dev server: `npm run dev` (uses Vite, NOT tsx)
- ‚úÖ Type checking: `npm run check` (uses `tsc`, NOT tsx)
- ‚úÖ Build: `npm run build` (uses Vite, NOT tsx)
- ‚úÖ Scripts: `npx tsx scripts/utility.ts` (ONLY for scripts)

**What to use instead of tsx**:
- React app development: `npm run dev` (Vite)
- Type checking: `npm run check` (TypeScript compiler)
- Building: `npm run build` (Vite)
- Testing: `npm run test:frontend` (Vitest)

### File Organization
- One component per file
- Hooks in `hooks/` directory
- API functions in `lib/api.ts`
- Types in `shared/` or component files

### Naming Conventions
- Components: PascalCase (`BotList.tsx`)
- Hooks: camelCase starting with `use` (`useBots.ts`)
- Utilities: camelCase (`formatCurrency.ts`)
- Types/Interfaces: PascalCase (`BotConfig`)

---

## ü§ñ Frontend-Specific Agent Behavior

### Default Mode: AUTONOMOUS OPERATION

**The agent operates in AUTONOMOUS MODE for all frontend tasks**, meaning:

- ‚úÖ **Automatically uses all tools** - MCP tools, browser tools, codebase search - NO ASKING
- ‚úÖ **Automatically researches** - Intelligence system, codebase patterns, external docs - NO ASKING
- ‚úÖ **Automatically plans** - Component architecture, hooks, state management - NO ASKING
- ‚úÖ **Automatically implements** - Components, hooks, API functions, tests - NO ASKING
- ‚úÖ **Automatically fixes issues** - TypeScript errors, lint errors, test failures - NO ASKING
- ‚úÖ **Automatically verifies** - Runs tests, checks bundle size, validates UI - NO ASKING

**The agent only asks when requirements are genuinely ambiguous (rare cases).**

### Mandatory Intelligence System Usage (AUTOMATIC)

**REQUIRED**: The agent MUST automatically use the intelligence system for EVERY frontend task - NO EXCEPTIONS.

**Before ANY frontend task, AUTOMATICALLY (MANDATORY):**
1. ‚úÖ **AUTOMATICALLY** Read `.cursor/extracted-patterns.md` - Find React Query Hook Pattern (42+ files), Optimistic Update Pattern (10+ files)
2. ‚úÖ **AUTOMATICALLY** Read `.cursor/knowledge-base.md` - Check for frontend patterns and solutions
3. ‚úÖ **AUTOMATICALLY** Read `.cursor/quick-reference.md` - Fast lookup for frontend patterns
4. ‚úÖ **AUTOMATICALLY** Use Memory-Bank: `read_global_memory_bank({ docs: ".cursor", path: "patterns/react-query-hook.json" })` - Retrieve stored patterns
5. ‚úÖ **AUTOMATICALLY** Check `.cursor/predictive-suggestions.md` - Get frontend-specific predictions
6. ‚úÖ **AUTOMATICALLY** Apply heuristics: Read `.cursor/intelligence-heuristics.md` - Frontend decision rules

**The agent does NOT ask** - it automatically uses the intelligence system before every frontend task.

**When creating hooks:**
- ‚úÖ Match React Query Hook Pattern from `.cursor/extracted-patterns.md`
- ‚úÖ Use `useAuth()` hook to check authentication
- ‚úÖ Set `enabled: isAuthenticated` to conditionally fetch
- ‚úÖ Set appropriate `staleTime` (2min for status, 30s for data)
- ‚úÖ Disable polling when WebSocket connected

**When creating mutations:**
- ‚úÖ Match Optimistic Update Pattern from `.cursor/extracted-patterns.md`
- ‚úÖ Use `onMutate` for optimistic update
- ‚úÖ Snapshot previous state for rollback
- ‚úÖ Use `onError` for rollback on failure
- ‚úÖ Use `onSettled` for query invalidation

**When creating API functions:**
- ‚úÖ Normalize trading modes ("live" ‚Üí "real") - Check Memory-Bank: `read_global_memory_bank({ docs: ".cursor", path: "decisions/trading-mode-normalization.json" })`
- ‚úÖ Use `apiRequest()` wrapper for all API calls
- ‚úÖ Handle query parameters properly

### Automatic Codebase Search (MANDATORY)

**The agent AUTOMATICALLY searches the codebase before implementing - NO ASKING:**

- ‚úÖ **AUTOMATICALLY** Search for similar UI patterns before creating components
- ‚úÖ **AUTOMATICALLY** Check existing React Query hooks before creating hooks
- ‚úÖ **AUTOMATICALLY** Verify API functions exist before API calls
- ‚úÖ **AUTOMATICALLY** Check existing Tailwind patterns before styling
- ‚úÖ **AUTOMATICALLY** Match patterns from `.cursor/extracted-patterns.md`

**Automatic search queries:**
- ‚úÖ "How are React Query hooks structured?" - AUTOMATICALLY search
- ‚úÖ "Where are API functions defined?" - AUTOMATICALLY search
- ‚úÖ "How is authentication handled in components?" - AUTOMATICALLY search
- ‚úÖ "What error handling patterns are used?" - AUTOMATICALLY search
- ‚úÖ "How are Web3 wallet connections implemented?" - AUTOMATICALLY search
- ‚úÖ "Where are DEX swap components located?" - AUTOMATICALLY search

**The agent does NOT ask** - it automatically searches before implementing.

### Automatic Frontend Code Generation

**The agent AUTOMATICALLY generates complete, production-ready code - NO ASKING:**

- ‚úÖ **AUTOMATICALLY** Include: TypeScript types, error boundaries, loading states, tests
- ‚úÖ **AUTOMATICALLY** Follow Component pattern: Props interface ‚Üí React Query hooks ‚Üí Error/Loading states ‚Üí Render
- ‚úÖ **AUTOMATICALLY** Follow Hook pattern: Query key ‚Üí Query function ‚Üí Options (staleTime, refetchInterval)
- ‚úÖ **AUTOMATICALLY** Follow API pattern: Function definition ‚Üí Type parameters ‚Üí apiRequest call ‚Üí Return typed result
- ‚úÖ **AUTOMATICALLY** Write tests: Render ‚Üí User interaction ‚Üí Assert state changes ‚Üí Cleanup
- ‚úÖ **AUTOMATICALLY** Match extracted patterns from `.cursor/extracted-patterns.md`
- ‚úÖ **AUTOMATICALLY** Apply predictive suggestions from `.cursor/predictive-suggestions.md`

**The agent does NOT ask** - it automatically generates complete code following all patterns.

**Do/Don't Patterns:**

**‚úÖ DO:**
- Use `Annotated` type hints in FastAPI dependencies (backend)
- Use CoinGecko MCP for price data in components
- Use Web3 MCP for blockchain operations in hooks
- Show price impact warnings for DEX swaps (>1% threshold)
- Handle wallet disconnection gracefully
- Support multi-chain wallet operations
- Poll transaction status until confirmed
- Display USD values for wallet balances when available

**‚ùå DON'T:**
- Don't use `any` type in TypeScript (use `unknown` instead)
- Don't duplicate server state in component state (use React Query)
- Don't log sensitive data (private keys, API keys, passwords)
- Don't execute swaps without price impact validation
- Don't skip error handling for blockchain operations
- Don't hardcode chain IDs (use configuration)
- Don't forget to normalize trading modes ("live" ‚Üí "real")
- Don't create new Web3 instances per request (reuse connections)

### Automatic Frontend Code Verification

**The agent AUTOMATICALLY verifies frontend code before completion - NO ASKING:**

**Automatic verification checklist (runs automatically):**
- ‚úÖ All components have TypeScript interfaces for props - AUTOMATICALLY verify
- ‚úÖ No `any` types (use `unknown` if needed) - AUTOMATICALLY verify
- ‚úÖ Loading states handled (LoadingSkeleton component) - AUTOMATICALLY verify
- ‚úÖ Error states handled (ErrorBoundary or error fallback) - AUTOMATICALLY verify
- ‚úÖ React Query used for server state (not component state) - AUTOMATICALLY verify
- ‚úÖ Query keys follow hierarchical pattern (`['domain', subKey]`) - AUTOMATICALLY verify
- ‚úÖ Trading modes normalized ("live" ‚Üí "real") before API calls - AUTOMATICALLY verify
- ‚úÖ Polling disabled when WebSocket connected - AUTOMATICALLY verify
- ‚úÖ Bundle size acceptable (check chunk sizes) - AUTOMATICALLY verify
- ‚úÖ Accessibility (semantic HTML, ARIA labels, keyboard nav) - AUTOMATICALLY verify
- ‚úÖ Web3 wallet connections handled gracefully - AUTOMATICALLY verify
- ‚úÖ DEX swap UI shows price impact warnings (>1% threshold) - AUTOMATICALLY verify
- ‚úÖ Transaction status tracked with proper polling - AUTOMATICALLY verify
- ‚úÖ Multi-chain support verified - AUTOMATICALLY verify
- ‚úÖ Wallet balances display USD values when available - AUTOMATICALLY verify

**The agent does NOT ask** - it automatically verifies all checks before completion.

### Automatic Frontend Debugging

**The agent AUTOMATICALLY debugs issues without asking - NO ASKING:**

1. ‚úÖ **AUTOMATICALLY** Check Browser DevTools: Network tab for API calls, Console for errors
2. ‚úÖ **AUTOMATICALLY** Use React DevTools: Inspect component tree, hooks, and state
3. ‚úÖ **AUTOMATICALLY** Check React Query DevTools: Query cache, mutations, loading states
4. ‚úÖ **AUTOMATICALLY** Run `npm run check` to find TypeScript errors
5. ‚úÖ **AUTOMATICALLY** Check Vite build output for bundle size warnings
6. ‚úÖ **AUTOMATICALLY** Use Browser MCP to visually test components
7. ‚úÖ **AUTOMATICALLY** Use React DevTools Profiler to identify slow components
8. ‚úÖ **AUTOMATICALLY** Run `npm run lint` to find lint errors
9. ‚úÖ **AUTOMATICALLY** Run tests to identify failing tests
10. ‚úÖ **AUTOMATICALLY** Use codebase search to find similar issues and solutions

**The agent does NOT ask** - it automatically debugs and fixes issues.

---

## üö® Critical Frontend Rules

1. **Always use TypeScript** - no `any`, use strict mode
2. **React Query for server state** - never duplicate in component state
3. **Handle loading/error states** - use LoadingSkeleton and ErrorBoundary
4. **Normalize trading modes** - "live" ‚Üí "real" for backend
5. **Test components** - unit tests with Vitest, E2E with Playwright
6. **Optimize bundle size** - monitor chunk sizes, lazy load heavy components
7. **Accessibility** - use semantic HTML, ARIA labels, keyboard navigation (WCAG 2.1 AA)
8. **Error handling** - always catch and display errors gracefully
9. **Auth tokens** - handle 401 errors, clear tokens, dispatch events
10. **WebSocket integration** - disable polling when WebSocket connected
11. **Search codebase first** - find existing components/hooks before creating new ones
12. **Use existing UI components** - prefer shadcn/ui over custom components
13. **Invalidate queries strategically** - use exact match, prefix match, or predicates
14. **Memoize expensive components** - use `React.memo` for components with stable props
15. **Memoize expensive operations** - use useMemo/useCallback for performance
16. **Test user flows** - write E2E tests for critical paths (including cross-browser)
17. **Web3 wallet connections** - handle disconnect gracefully, support chain switching
18. **DEX swap UI** - show price impact warnings (>1% threshold), validate slippage
19. **Transaction status** - poll blockchain until confirmed, show loading states
20. **Multi-chain support** - verify wallet operations work across all supported chains
21. **Wallet balances** - display USD values when price data available (CoinGecko MCP)
22. **Request deduplication** - use `deduplicateRequest` from `@/utils/performance` for GET requests
23. **Virtual scrolling** - use `useVirtualScroll` hook for lists with 100+ items
24. **Image optimization** - use WebP/AVIF with lazy loading via `useLazyImage` hook
25. **Form validation** - use `useFormValidation` hook for real-time validation with debouncing
26. **Minimum touch targets** - ensure 44x44px minimum for mobile interactions
27. **Safe area insets** - use `safe-area-inset-*` classes for mobile devices
28. **Page transitions** - use `PageTransition` component for smooth page changes
29. **Accessibility utilities** - use `@/utils/accessibility` for focus trapping, announcements
30. **Component memoization** - wrap expensive components with `React.memo` (BotCreator, OrderEntryPanel, etc.)
31. **Mobile offline mode** - queue actions when offline, sync when online
32. **Mobile push notifications** - integrate Expo push notifications with backend
33. **Mobile biometric auth** - use for sensitive operations (transactions, app unlock)
34. **Cross-browser testing** - test on Chromium, Firefox, WebKit in CI/CD
35. **Coverage gates** - maintain 85%+ test coverage, enforce in PRs

---

## üìö Reference Files

- **Project Rules**: `.cursor/rules/cursorprojectrules.mdc`
- **API Client**: `client/src/lib/api.ts`
- **React Query Setup**: `client/src/lib/queryClient.ts`
- **Vite Config**: `vite.config.ts`
- **TypeScript Config**: `tsconfig.json`
- **ESLint Config**: `.eslintrc.json`
- **Prettier Config**: `.prettierrc.json`
- **üéì TypeScript Expertise Guide**: `.cursor/TYPESCRIPT_EXPERTISE_GUIDE.md` - **COMPREHENSIVE TYPESCRIPT KNOWLEDGE**
- **TypeScript Tools Guide**: `.cursor/TYPESCRIPT_TOOLS_GUIDE.md` - **EXTENSIONS & MCP SERVERS**
- **‚ö†Ô∏è tsx Usage Rules**: `.cursor/AGENT_TSX_RULES.md` - **CRITICAL RULES**

---

**Remember**: Frontend code should be:
- **Type-safe** (TypeScript strict mode)
- **Performant** (code splitting, memoization)
- **Accessible** (semantic HTML, ARIA)
- **Tested** (unit + E2E tests)
- **User-friendly** (loading states, error handling)
