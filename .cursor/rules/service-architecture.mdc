---
description: Service layer architecture patterns, repository patterns, and dependency injection for CryptoOrchestrator
globs: ["server_fastapi/services/**/*", "server_fastapi/repositories/**/*", "server_fastapi/dependencies/**/*"]
alwaysApply: false
---

# Service Architecture Rules

## Service Layer Pattern

### Stateless Services
```python
# ✅ Good: Stateless service (no instance state)
class TradingService:
    """Service for trading operations."""
    
    def __init__(
        self,
        db: AsyncSession,
        trade_repository: Optional[TradeRepository] = None,
    ):
        # ✅ Dependencies injected, no state stored
        self.trade_repository = trade_repository or TradeRepository()
        self.db = db
    
    async def execute_trade(self, trade_data: dict) -> dict:
        """Execute a trade - pure business logic."""
        # Business logic only, no state mutation
        pass

# ❌ Bad: Service with state
class BadTradingService:
    def __init__(self):
        self.cache = {}  # ❌ Instance state
        self.counter = 0  # ❌ Instance state
```

### Repository Delegation
```python
# ✅ Good: Service delegates data access to repository
class TradingService:
    async def get_trade(self, trade_id: int) -> Optional[Trade]:
        """Get trade by ID."""
        # ✅ Delegate to repository
        return await self.trade_repository.get_by_id(self.db, trade_id)
    
    async def create_trade(self, trade_data: dict) -> Trade:
        """Create a new trade."""
        # ✅ Business logic in service
        if trade_data["amount"] <= 0:
            raise ValueError("Amount must be positive")
        
        # ✅ Delegate data access to repository
        return await self.trade_repository.create(self.db, trade_data)

# ❌ Bad: Service directly queries database
class BadTradingService:
    async def get_trade(self, trade_id: int) -> Optional[Trade]:
        # ❌ Direct database access
        query = select(Trade).where(Trade.id == trade_id)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()
```

## Repository Pattern

### Base Repository
```python
# ✅ Good: Use base repository pattern
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

class TradeRepository:
    """Repository for trade data access."""
    
    def __init__(self):
        self.model_class = Trade
    
    async def get_by_id(
        self,
        session: AsyncSession,
        trade_id: int,
    ) -> Optional[Trade]:
        """Get trade by ID with eager loading."""
        query = (
            select(Trade)
            .options(selectinload(Trade.user))  # ✅ Eager load relationships
            .where(Trade.id == trade_id)
        )
        result = await session.execute(query)
        return result.scalar_one_or_none()
    
    async def get_by_user(
        self,
        session: AsyncSession,
        user_id: int,
        skip: int = 0,
        limit: int = 100,
    ) -> List[Trade]:
        """Get trades for user with pagination."""
        query = (
            select(Trade)
            .options(selectinload(Trade.user))
            .where(Trade.user_id == user_id)
            .order_by(Trade.created_at.desc())
            .offset(skip)
            .limit(limit)
        )
        result = await session.execute(query)
        return result.scalars().all()
    
    async def create(
        self,
        session: AsyncSession,
        data: dict,
    ) -> Trade:
        """Create a new trade."""
        trade = Trade(**data)
        session.add(trade)
        await session.commit()
        await session.refresh(trade)
        return trade
```

### Eager Loading
```python
# ✅ Good: Always use eager loading to prevent N+1 queries
query = (
    select(Bot)
    .options(
        selectinload(Bot.user),  # ✅ Eager load user
        selectinload(Bot.trades),  # ✅ Eager load trades
    )
    .where(Bot.user_id == user_id)
)

# ❌ Bad: Lazy loading causes N+1 queries
query = select(Bot).where(Bot.user_id == user_id)
# Later: bot.user.email  # ❌ Triggers additional query
```

## Dependency Injection

### Service Dependencies
```python
# ✅ Good: Dependency function for service injection
from typing import Annotated
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession
from ..database import get_db_session
from ..services.trading_service import TradingService
from ..repositories.trade_repository import TradeRepository

async def get_trading_service(
    db: Annotated[AsyncSession, Depends(get_db_session)],
) -> TradingService:
    """Provide trading service with injected dependencies."""
    # ✅ Create repositories
    trade_repository = TradeRepository()
    
    # ✅ Inject into service
    return TradingService(
        db=db,
        trade_repository=trade_repository,
    )

# Use in routes
@router.post("/api/trades")
async def create_trade(
    trade_data: TradeRequest,
    trading_service: Annotated[TradingService, Depends(get_trading_service)],
):
    return await trading_service.create_trade(trade_data.dict())
```

### Route Pattern
```python
# ✅ Good: Thin route handlers, delegate to services
@router.post("/api/trades", response_model=TradeResponse, status_code=201)
async def create_trade(
    trade_data: TradeRequest,
    current_user: Annotated[dict, Depends(get_current_user)],
    trading_service: Annotated[TradingService, Depends(get_trading_service)],
) -> TradeResponse:
    """Create a new trade."""
    # ✅ Route is thin - just validation and delegation
    if trade_data.user_id != current_user["id"]:
        raise HTTPException(status_code=403, detail="Cannot create trade for another user")
    
    # ✅ Delegate to service
    trade = await trading_service.create_trade(
        trade_data.dict(),
        user_id=current_user["id"],
    )
    
    return TradeResponse.from_orm(trade)

# ❌ Bad: Business logic in route
@router.post("/api/trades")
async def create_trade(trade_data: TradeRequest, db: AsyncSession):
    # ❌ Business logic in route
    if trade_data.amount <= 0:
        raise ValueError("Amount must be positive")
    
    # ❌ Direct database access
    trade = Trade(**trade_data.dict())
    db.add(trade)
    await db.commit()
    return trade
```

## Transaction Management

### Transaction Boundaries
```python
# ✅ Good: Use transactions for multi-step operations
async def execute_trade_with_fee(
    self,
    trade_data: dict,
    fee_percentage: float,
) -> dict:
    """Execute trade and charge fee in single transaction."""
    async with self.db.begin():  # ✅ Transaction boundary
        # 1. Create trade
        trade = await self.trade_repository.create(self.db, trade_data)
        
        # 2. Calculate and charge fee
        fee_amount = trade.amount * fee_percentage
        await self.fee_repository.create(self.db, {
            "trade_id": trade.id,
            "amount": fee_amount,
        })
        
        # 3. Update user balance
        await self.balance_repository.deduct(self.db, {
            "user_id": trade.user_id,
            "amount": fee_amount,
        })
        
        # Transaction commits automatically on success
        # Rolls back automatically on exception
        return {"trade_id": trade.id, "fee_amount": fee_amount}
```

## Error Handling in Services

### Service Error Patterns
```python
# ✅ Good: Specific exceptions with context
async def execute_trade(self, trade_data: dict) -> dict:
    """Execute a trade with proper error handling."""
    try:
        # Validate inputs
        if trade_data["amount"] <= 0:
            raise ValueError("Trade amount must be positive")
        
        # Check balance
        balance = await self.balance_service.get_balance(
            trade_data["user_id"], trade_data["token"]
        )
        if balance < trade_data["amount"]:
            raise InsufficientBalanceError(
                f"Insufficient balance: {balance} < {trade_data['amount']}"
            )
        
        # Execute trade
        return await self._execute_trade_internal(trade_data)
        
    except InsufficientBalanceError:
        # Re-raise domain exceptions
        raise
    except Exception as e:
        # Log and wrap unexpected errors
        logger.error(f"Trade execution failed: {e}", exc_info=True)
        raise TradeExecutionError(f"Failed to execute trade: {str(e)}")
```

## Service Composition

### Service-to-Service Communication
```python
# ✅ Good: Services can depend on other services
class TradingService:
    def __init__(
        self,
        db: AsyncSession,
        risk_service: Optional[RiskService] = None,
        balance_service: Optional[BalanceService] = None,
    ):
        self.db = db
        self.risk_service = risk_service or RiskService()
        self.balance_service = balance_service or BalanceService()
    
    async def execute_trade(self, trade_data: dict) -> dict:
        """Execute trade with risk and balance checks."""
        # ✅ Use other services for cross-cutting concerns
        risk_check = await self.risk_service.validate_trade(trade_data)
        if not risk_check.approved:
            raise RiskLimitExceededError(risk_check.reason)
        
        balance = await self.balance_service.get_balance(
            trade_data["user_id"], trade_data["token"]
        )
        if balance < trade_data["amount"]:
            raise InsufficientBalanceError()
        
        # Execute trade
        return await self._execute_trade_internal(trade_data)
```

## Best Practices

1. **Services are stateless** - No instance variables that change
2. **Repositories handle data access** - Services delegate to repositories
3. **Dependency injection** - Services receive dependencies via constructor
4. **Eager loading** - Always use `selectinload` or `joinedload` to prevent N+1
5. **Transaction boundaries** - Use `async with db.begin()` for multi-step operations
6. **Thin routes** - Routes validate and delegate, business logic in services
7. **Error handling** - Use specific exceptions, log errors with context
8. **Service composition** - Services can depend on other services
9. **Async everywhere** - All I/O operations use `async def` and `await`
10. **Type hints** - All functions have complete type hints
