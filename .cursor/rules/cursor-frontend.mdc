---
alwaysApply: true
---
# CryptoOrchestrator - Frontend Development Rules

You are an expert frontend software engineer specializing in this production-ready cryptocurrency trading automation platform. Follow these rules when working on frontend code.

> **Note**: This file focuses on frontend-specific rules. See `.cursor/rules/cursorprojectrules.mdc` for full-stack patterns and architecture.

## üé® Frontend Stack & Architecture

### Core Technologies
- **Framework**: React 18+ with TypeScript (strict mode enabled)
- **Build System**: Vite with manual code splitting
- **State Management**: 
  - **Server State**: TanStack Query (React Query) v5+
  - **UI State**: React useState/useReducer
  - **Global State**: Zustand (when needed)
  - **Form State**: React Hook Form with Zod validation
- **UI Components**: shadcn/ui (Radix UI primitives)
- **Styling**: Tailwind CSS with dark mode support
- **Routing**: React Router (if used) or component-based routing
- **Desktop**: Electron wrapper (for desktop builds)
- **PWA**: Vite PWA plugin for offline support

### Directory Structure
```
client/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/          # UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/             # shadcn/ui base components
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [feature]/      # Feature-specific components
‚îÇ   ‚îú‚îÄ‚îÄ hooks/               # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useApi.ts       # React Query hooks
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [feature].ts    # Feature hooks
‚îÇ   ‚îú‚îÄ‚îÄ lib/                 # Utilities & API clients
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api.ts          # API function definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ queryClient.ts  # React Query setup
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts        # Helper functions
‚îÇ   ‚îú‚îÄ‚îÄ pages/               # Page components
‚îÇ   ‚îú‚îÄ‚îÄ contexts/            # React contexts
‚îÇ   ‚îú‚îÄ‚îÄ locales/             # i18n translations
‚îÇ   ‚îî‚îÄ‚îÄ test/                # Test utilities
‚îú‚îÄ‚îÄ public/                  # Static assets
‚îú‚îÄ‚îÄ index.html
‚îî‚îÄ‚îÄ vite.config.ts
```

### Path Aliases
- `@/*` ‚Üí `client/src/*`
- `@shared/*` ‚Üí `shared/*`

---

## üîÑ React Query (TanStack Query) Patterns

### Query Key Structure
```typescript
// ‚úÖ Good: Hierarchical query keys
['bots']                    // All bots
['bots', botId]            // Single bot
['bots', botId, 'trades']  // Bot trades
['trades', { botId, mode }] // Trades with filters

// ‚ùå Bad: Flat or inconsistent keys
['bot-list'] // Don't use descriptive strings
['bot', id]  // Inconsistent with ['bots', id]
```

### Query Hooks Pattern
```typescript
// client/src/hooks/useApi.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { botApi } from '@/lib/api';

export const useBots = () => {
  return useQuery({
    queryKey: ['bots'],
    queryFn: () => botApi.getBots(),
    staleTime: 30000, // 30 seconds
    refetchInterval: false, // Disable polling when WebSocket available
  });
};

export const useBot = (botId: string) => {
  return useQuery({
    queryKey: ['bots', botId],
    queryFn: () => botApi.getBot(botId),
    enabled: !!botId, // Only fetch if botId exists
    staleTime: 30000,
  });
};

export const useCreateBot = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (bot: InsertBotConfig) => botApi.createBot(bot),
    onSuccess: () => {
      // Invalidate all bots queries (prefix match by default)
      queryClient.invalidateQueries({ queryKey: ['bots'] });
    },
  });
};
```

### Query Invalidation Patterns
```typescript
// ‚úÖ Prefix matching (default) - invalidates all ['bots', ...] queries
queryClient.invalidateQueries({ queryKey: ['bots'] });

// ‚úÖ Exact matching - only invalidates exact ['bots'] key
queryClient.invalidateQueries({ queryKey: ['bots'], exact: true });

// ‚úÖ Predicate function - complex invalidation logic
queryClient.invalidateQueries({
  predicate: (query) => 
    query.queryKey[0] === 'bots' && 
    query.state.data?.version >= 10
});

// ‚úÖ Refetch control
queryClient.invalidateQueries({
  queryKey: ['bots'],
  refetchType: 'active' | 'inactive' | 'all' | 'none'
});
```

### Polling vs WebSocket
- **Use polling** for resources that need periodic updates (5000ms interval)
- **Disable polling** when WebSocket is connected (real-time updates)
- **Example**:
  ```typescript
  const { isConnected } = useWebSocket();
  const { data } = useQuery({
    queryKey: ['bot-status', botId],
    queryFn: () => botApi.getBotStatus(botId),
    refetchInterval: isConnected ? false : 5000,
  });
  ```

---

## üì° API Client Patterns

### API Function Definition
```typescript
// client/src/lib/api.ts
import { apiRequest } from './queryClient';
import type { BotConfig, InsertBotConfig } from '@shared/schema';

export const botApi = {
  getBots: () => apiRequest("/api/bots", { method: "GET" }),
  
  createBot: (bot: InsertBotConfig) => 
    apiRequest("/api/bots", { method: "POST", body: bot }),
  
  updateBot: (id: string, updates: Partial<BotConfig>) =>
    apiRequest(`/api/bots/${id}`, { method: "PATCH", body: updates }),
};

// Trading mode normalization: "live" ‚Üí "real" for backend
export const portfolioApi = {
  getPortfolio: (mode: "paper" | "real" | "live") => {
    const normalizedMode = mode === "live" ? "real" : mode;
    return apiRequest(`/api/portfolio?mode=${normalizedMode}`, { method: "GET" });
  },
};
```

### Error Handling
```typescript
// client/src/lib/queryClient.ts - API request wrapper
export async function apiRequest<T>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  const token = localStorage.getItem('token');
  
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
      ...options.headers,
    },
  });

  if (!response.ok) {
    if (response.status === 401) {
      // Handle auth expiration
      localStorage.removeItem('token');
      window.dispatchEvent(new CustomEvent('auth:expired'));
      throw new Error('Authentication expired');
    }
    const error = await response.json().catch(() => ({ message: 'Unknown error' }));
    throw new Error(error.message || `HTTP ${response.status}`);
  }

  return response.json();
}
```

---

## üß© Component Patterns

### Component Structure
```typescript
// ‚úÖ Good: TypeScript interface, proper typing, error handling
import { useBots, useCreateBot } from '@/hooks/useApi';
import { Button } from '@/components/ui/button';
import { LoadingSkeleton } from '@/components/LoadingSkeleton';
import { ErrorBoundary } from '@/components/ErrorBoundary';

interface BotListProps {
  userId?: string;
}

export function BotList({ userId }: BotListProps) {
  const { data: bots, isLoading, error } = useBots();
  const createBot = useCreateBot();

  if (isLoading) return <LoadingSkeleton />;
  if (error) return <ErrorFallback error={error} />;

  return (
    <ErrorBoundary>
      <div>
        {bots?.map(bot => <BotCard key={bot.id} bot={bot} />)}
      </div>
    </ErrorBoundary>
  );
}
```

### Form Patterns with React Hook Form + Zod
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const createBotSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  strategy: z.enum(['momentum', 'mean_reversion']),
});

type CreateBotForm = z.infer<typeof createBotSchema>;

export function BotCreator() {
  const createBot = useCreateBot();
  
  const form = useForm<CreateBotForm>({
    resolver: zodResolver(createBotSchema),
    defaultValues: { name: '', strategy: 'momentum' },
  });

  const onSubmit = (data: CreateBotForm) => {
    createBot.mutate(data, {
      onSuccess: () => form.reset(),
    });
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* Form fields */}
    </form>
  );
}
```

### Loading & Error States
```typescript
// ‚úÖ Use LoadingSkeleton component for loading states
import { LoadingSkeleton } from '@/components/LoadingSkeleton';

if (isLoading) return <LoadingSkeleton />;

// ‚úÖ Use ErrorBoundary for component errors
import { ErrorBoundary } from '@/components/ErrorBoundary';

<ErrorBoundary
  fallback={<ErrorFallback />}
  onError={(error, errorInfo) => {
    logger.error('Component error', { error, errorInfo });
  }}
>
  <YourComponent />
</ErrorBoundary>
```

---

## üéØ State Management Guidelines

### Server State ‚Üí React Query
- All API data should use React Query
- Never duplicate server state in component state
- Use React Query cache as source of truth

### UI State ‚Üí useState/useReducer
- Form inputs, modals, dropdowns, etc.
- Keep local to component when possible

### Global UI State ‚Üí Zustand (if needed)
```typescript
// Only for complex shared UI state (theme, preferences)
import { create } from 'zustand';

interface ThemeStore {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

export const useThemeStore = create<ThemeStore>((set) => ({
  theme: 'dark',
  toggleTheme: () => set((state) => ({ 
    theme: state.theme === 'light' ? 'dark' : 'light' 
  })),
}));
```

---

## üß™ Testing Patterns

### Component Tests (Vitest + Testing Library)
```typescript
// client/src/components/__tests__/BotList.test.tsx
import { render, screen } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BotList } from '../BotList';

const queryClient = new QueryClient({
  defaultOptions: { queries: { retry: false } },
});

test('renders bot list', async () => {
  render(
    <QueryClientProvider client={queryClient}>
      <BotList />
    </QueryClientProvider>
  );
  
  expect(await screen.findByText('Test Bot')).toBeInTheDocument();
});
```

### Hook Tests
```typescript
// client/src/hooks/__tests__/useApi.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useBots } from '../useApi';

test('fetches bots', async () => {
  const queryClient = new QueryClient();
  const wrapper = ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );

  const { result } = renderHook(() => useBots(), { wrapper });

  await waitFor(() => expect(result.current.isSuccess).toBe(true));
  expect(result.current.data).toHaveLength(1);
});
```

### E2E Tests (Playwright)
```typescript
// tests/e2e/bots.spec.ts
import { test, expect } from '@playwright/test';

test('should create bot successfully', async ({ page }) => {
  await page.goto('/bots');
  await page.getByTestId('create-bot-btn').click();
  await page.fill('input[name="name"]', 'Test Bot');
  await page.selectOption('select[name="strategy"]', 'momentum');
  await page.click('button[type="submit"]');
  
  await expect(page.locator('text=Test Bot')).toBeVisible();
  await expect(page).toHaveURL(/\/bots/);
});
```

---

## üé® Styling Guidelines

### Tailwind CSS
- Use Tailwind utility classes (no custom CSS unless necessary)
- Dark mode: Use `dark:` prefix for dark mode styles
- Responsive: Use breakpoint prefixes (`sm:`, `md:`, `lg:`)
- Custom theme: Extend in `tailwind.config.ts`

### shadcn/ui Components
- Components in `client/src/components/ui/` (Radix UI primitives)
- Use existing components: `Button`, `Card`, `Dialog`, `Select`, etc.
- Customize via Tailwind classes, not by modifying base components

---

## ‚ö° Performance Optimization

### Code Splitting
- Vite automatically splits vendor chunks (see `vite.config.ts`)
- Manual chunks: React, React Query, Charts, Radix UI, Icons
- Lazy load routes and heavy components:
  ```typescript
  const HeavyComponent = lazy(() => import('./HeavyComponent'));
  ```

### React Optimization
- Use `React.memo` for expensive components
- Use `useMemo` for expensive computations
- Use `useCallback` for stable function references
- Debounce/throttle API calls in search/filters

### Bundle Size
- Chunk size warning limit: 1MB (configured in `vite.config.ts`)
- Monitor bundle with `npm run build` (Vite visualizer)
- Remove unused dependencies

---

## üîß TypeScript Strict Mode

### Strict Patterns
```typescript
// ‚úÖ Use strictNullChecks
const bot: BotConfig | undefined = data;
if (bot) {
  // TypeScript knows bot is defined here
  console.log(bot.name);
}

// ‚úÖ Avoid `any` - use `unknown` for truly unknown types
function handleError(error: unknown) {
  if (error instanceof Error) {
    console.error(error.message);
  }
}

// ‚úÖ Use type predicates for type narrowing
function isBotConfig(value: unknown): value is BotConfig {
  return typeof value === 'object' && value !== null && 'id' in value;
}

// ‚úÖ Use const assertions for enum-like patterns
const TradingMode = {
  PAPER: 'paper',
  REAL: 'real',
} as const;

type TradingMode = typeof TradingMode[keyof typeof TradingMode];
```

---

## üêõ Frontend Debugging

### Browser Console
- Check JavaScript errors, React warnings
- Monitor network requests (Network tab)
- Inspect React Query cache: `window.__REACT_QUERY_STATE__ = queryClient.getQueryCache()`

### React DevTools
- Inspect component tree, hooks, state
- Profile performance (React DevTools Profiler)
- Check React Query DevTools for cache state

### Common Issues

**Component not re-rendering:**
```typescript
// Check if props/state actually changed
console.log('Props:', props);
console.log('State:', state);
// Use React DevTools Profiler
```

**API call failing:**
```typescript
// Check Network tab: URL, headers, response
// Verify auth token in request headers
apiRequest('/api/bots').catch(err => {
  console.error('API Error:', err);
});
```

**React Query cache stale:**
```typescript
// Check React Query DevTools
// Or force refetch:
queryClient.invalidateQueries({ queryKey: ['bots'] });
```

---

## üîß MCP Integration for Frontend

### Available MCP Tools
- **Puppeteer**: Browser automation for testing and UI verification
- **Context7**: Get latest React, TypeScript, TanStack Query, Vite documentation
- **StackOverflow**: Search for React/TypeScript patterns and solutions
- **Brave Search**: Find frontend best practices and modern patterns
- **Memory/Memory-Bank**: Store frontend patterns and solutions for future reference
- **Filesystem**: Advanced file operations when working with components
- **Git**: Version control operations for frontend code
- **GitHub**: GitHub integration for issues, PRs, and repository management
- **Render**: Deploy frontend builds to Render
- **Sequential Thinking**: Complex problem-solving for frontend architecture

### When to Use MCPs

**Puppeteer (Browser Automation):**
- Verify UI components render correctly
- Test user flows and interactions programmatically
- Take screenshots for visual verification
- Debug frontend issues interactively
- Automate E2E testing workflows
- Test responsive design across viewports

**Context7 (Documentation):**
- "Get latest React Query invalidation patterns"
- "Find TypeScript strict mode best practices"
- "Get React 18+ hook patterns"
- "Vite build optimization techniques"
- "TanStack Query v5 migration guide"
- "shadcn/ui component patterns"

**StackOverflow (Patterns & Solutions):**
- Search for React/TypeScript error messages
- Find common patterns and solutions
- Check for known issues with libraries
- Learn from community solutions
- Troubleshoot build/compilation errors

**Brave Search (Best Practices):**
- "React performance optimization 2024"
- "TypeScript strict mode patterns"
- "Frontend security best practices"
- "Accessibility best practices React"
- "Vite production optimization"

**Memory/Memory-Bank (Knowledge Storage):**
- Store custom component patterns
- Save complex hook implementations
- Remember architecture decisions
- Document frontend solutions

**Filesystem:**
- Bulk file operations
- Component scaffolding
- File structure management
- Search across codebase

**Git/GitHub:**
- Create branches for features
- Review PRs and issues
- Commit frontend changes
- Collaborate on frontend code

### Example Usage
```typescript
// Use Context7 to get latest React Query docs
// Use Puppeteer to test login flow and take screenshots
// Use StackOverflow to search for "React Query cache not updating"
// Use Memory-Bank to store a custom hook pattern
// Use Brave Search for "React 18 concurrent features"
```

---

## üìù Code Quality Standards

### TypeScript
- **Formatter**: Prettier (follow `.prettierrc.json`)
- **Linter**: ESLint (follow `.eslintrc.json`)
- **Strict mode**: All strict flags enabled (see `tsconfig.json`)
- **No `any`**: Use `unknown` for truly unknown types

### File Organization
- One component per file
- Hooks in `hooks/` directory
- API functions in `lib/api.ts`
- Types in `shared/` or component files

### Naming Conventions
- Components: PascalCase (`BotList.tsx`)
- Hooks: camelCase starting with `use` (`useBots.ts`)
- Utilities: camelCase (`formatCurrency.ts`)
- Types/Interfaces: PascalCase (`BotConfig`)

---

## ü§ñ Frontend-Specific Agent Behavior

### Codebase Search Patterns
- **Before creating components**: Search for similar UI patterns and components
- **Before creating hooks**: Check existing React Query hooks and patterns
- **Before API calls**: Verify API functions exist in `client/src/lib/api.ts`
- **Before styling**: Check existing Tailwind patterns and shadcn/ui components
- **Query examples**:
  - "How are React Query hooks structured?"
  - "Where are API functions defined?"
  - "How is authentication handled in components?"
  - "What error handling patterns are used?"

### Frontend Code Generation
- **Always include**: TypeScript types, error boundaries, loading states, tests
- **Component pattern**: Props interface ‚Üí React Query hooks ‚Üí Error/Loading states ‚Üí Render
- **Hook pattern**: Query key ‚Üí Query function ‚Üí Options (staleTime, refetchInterval)
- **API pattern**: Function definition ‚Üí Type parameters ‚Üí apiRequest call ‚Üí Return typed result
- **Test pattern**: Render ‚Üí User interaction ‚Üí Assert state changes ‚Üí Cleanup

### Frontend-Specific Checks
Before submitting frontend code, verify:
- ‚úÖ All components have TypeScript interfaces for props
- ‚úÖ No `any` types (use `unknown` if needed)
- ‚úÖ Loading states handled (LoadingSkeleton component)
- ‚úÖ Error states handled (ErrorBoundary or error fallback)
- ‚úÖ React Query used for server state (not component state)
- ‚úÖ Query keys follow hierarchical pattern (`['domain', subKey]`)
- ‚úÖ Trading modes normalized ("live" ‚Üí "real") before API calls
- ‚úÖ Polling disabled when WebSocket connected
- ‚úÖ Bundle size acceptable (check chunk sizes)
- ‚úÖ Accessibility (semantic HTML, ARIA labels, keyboard nav)

### Frontend Debugging Strategy
1. **Browser DevTools**: Check Network tab for API calls, Console for errors
2. **React DevTools**: Inspect component tree, hooks, and state
3. **React Query DevTools**: Check query cache, mutations, loading states
4. **TypeScript errors**: Use `npm run check` to find type issues
5. **Build issues**: Check Vite build output for bundle size warnings
6. **UI issues**: Use Browser MCP to visually test components
7. **Performance**: Use React DevTools Profiler to identify slow components

---

## üö® Critical Frontend Rules

1. **Always use TypeScript** - no `any`, use strict mode
2. **React Query for server state** - never duplicate in component state
3. **Handle loading/error states** - use LoadingSkeleton and ErrorBoundary
4. **Normalize trading modes** - "live" ‚Üí "real" for backend
5. **Test components** - unit tests with Vitest, E2E with Playwright
6. **Optimize bundle size** - monitor chunk sizes, lazy load heavy components
7. **Accessibility** - use semantic HTML, ARIA labels, keyboard navigation
8. **Error handling** - always catch and display errors gracefully
9. **Auth tokens** - handle 401 errors, clear tokens, dispatch events
10. **WebSocket integration** - disable polling when WebSocket connected
11. **Search codebase first** - find existing components/hooks before creating new ones
12. **Use existing UI components** - prefer shadcn/ui over custom components
13. **Invalidate queries strategically** - use exact match, prefix match, or predicates
14. **Memoize expensive operations** - use useMemo/useCallback for performance
15. **Test user flows** - write E2E tests for critical paths

---

## üìö Reference Files

- **Project Rules**: `.cursor/rules/cursorprojectrules.mdc`
- **API Client**: `client/src/lib/api.ts`
- **React Query Setup**: `client/src/lib/queryClient.ts`
- **Vite Config**: `vite.config.ts`
- **TypeScript Config**: `tsconfig.json`
- **ESLint Config**: `.eslintrc.json`
- **Prettier Config**: `.prettierrc.json`

---

**Remember**: Frontend code should be:
- **Type-safe** (TypeScript strict mode)
- **Performant** (code splitting, memoization)
- **Accessible** (semantic HTML, ARIA)
- **Tested** (unit + E2E tests)
- **User-friendly** (loading states, error handling)
