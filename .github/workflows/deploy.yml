name: Deploy

on:
  push:
    branches: [ main, develop ]
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests (use with caution)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and push Docker image
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=staging,enable={{is_default_branch}}
          type=raw,value=staging-{{date 'YYYYMMDD-HHmmss'}},enable={{is_default_branch}}
          type=semver,pattern={{version}},enable={{is_tag}}
          type=semver,pattern={{major}}.{{minor}},enable={{is_tag}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ github.ref_name }}
    
    - name: Build frontend
      run: |
        npm ci --legacy-peer-deps
        npm run build
        npm run build:electron || echo "Electron build optional"
    
    - name: Create release artifacts
      run: |
        mkdir -p dist/artifacts
        tar -czf dist/artifacts/frontend.tar.gz -C dist . || echo "Frontend build not found"
        tar -czf dist/artifacts/electron.tar.gz -C dist-electron . || echo "Electron build not found"
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v5
      with:
        name: build-artifacts
        path: dist/artifacts/
        retention-days: 30
        if-no-files-found: warn

  # Test migrations before deployment
  test-migrations:
    name: Test Database Migrations
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event.inputs.skip_tests != 'true'
    
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_migrations
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Test migration upgrade
      env:
        DATABASE_URL: postgresql+asyncpg://postgres:postgres@localhost:5432/test_migrations
      run: |
        echo "Testing migration upgrade..."
        python -m alembic upgrade head
    
    - name: Validate migration SQL
      env:
        DATABASE_URL: postgresql+asyncpg://postgres:postgres@localhost:5432/test_migrations
      run: |
        python -c "
        import os
        from pathlib import Path
        
        alembic_dir = Path('alembic/versions')
        if not alembic_dir.exists():
            print('No migrations directory found')
            exit(0)
        
        errors = []
        for migration_file in alembic_dir.glob('*.py'):
            with open(migration_file, 'r') as f:
                content = f.read()
            
            if 'DROP TABLE' in content and 'IF EXISTS' not in content:
                errors.append(f'{migration_file.name}: DROP TABLE without IF EXISTS')
            
            if 'DROP COLUMN' in content and 'IF EXISTS' not in content:
                errors.append(f'{migration_file.name}: DROP COLUMN without IF EXISTS')
        
        if errors:
            print('Migration validation errors:')
            for error in errors:
                print(f'  - {error}')
            exit(1)
        else:
            print('All migrations validated successfully')
        "

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-push, test-migrations]
    if: always() && (needs.test-migrations.result == 'success' || needs.test-migrations.result == 'skipped' || github.event.inputs.skip_tests == 'true') && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging'))
    environment:
      name: staging
      url: ${{ secrets.STAGING_URL || 'https://staging.example.com' }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Pull staging image
      run: |
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging || \
        docker pull ${{ needs.build-and-push.outputs.image-tag }} || \
        echo "Image pull failed, will use build output"
    
    - name: Run database migrations (staging)
      env:
        DATABASE_URL: ${{ secrets.STAGING_DATABASE_URL }}
      run: |
        echo "Running database migrations on staging..."
        if [ -z "$DATABASE_URL" ]; then
          echo "âš ï¸ STAGING_DATABASE_URL not set, skipping migrations"
          exit 0
        fi
        
        # Run migrations using the Docker image
        docker run --rm \
          --network host \
          -e DATABASE_URL="$DATABASE_URL" \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging \
          python -m alembic upgrade head || {
            echo "Migration failed! Deployment aborted."
            exit 1
          }
        echo "âœ“ Migrations applied successfully"
    
    - name: Deploy to staging
      env:
        STAGING_DEPLOY_METHOD: ${{ secrets.STAGING_DEPLOY_METHOD || 'docker-compose' }}
      run: |
        echo "Deploying to staging using $STAGING_DEPLOY_METHOD..."
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging"
        echo ""
        echo "Deployment steps:"
        echo "1. Pull latest image: docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging"
        echo "2. Update docker-compose: docker-compose -f docker-compose.prod.yml pull backend"
        echo "3. Restart services: docker-compose -f docker-compose.prod.yml up -d backend"
        echo ""
        echo "For Kubernetes:"
        echo "kubectl set image deployment/cryptoorchestrator-backend backend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging -n staging"
    
    - name: Wait for deployment to be ready
      env:
        STAGING_URL: ${{ secrets.STAGING_URL || 'http://localhost:8000' }}
      run: |
        echo "Waiting for staging deployment to be ready..."
        max_attempts=30
        attempt=0
        
        while [ $attempt -lt $max_attempts ]; do
          if curl -f "$STAGING_URL/healthz" > /dev/null 2>&1; then
            echo "âœ“ Staging deployment is healthy"
            exit 0
          fi
          attempt=$((attempt + 1))
          echo "Waiting for health check... ($attempt/$max_attempts)"
          sleep 10
        done
        
        echo "âš ï¸ Staging deployment health check timeout (may not be deployed yet)"
    
    - name: Run comprehensive health checks
      env:
        STAGING_URL: ${{ secrets.STAGING_URL || 'http://localhost:8000' }}
      run: |
        echo "Running comprehensive health checks..."
        
        if [ -z "$STAGING_URL" ] || [ "$STAGING_URL" == "http://localhost:8000" ]; then
          echo "âš ï¸ STAGING_URL not configured, skipping health checks"
          exit 0
        fi
        
        # Basic health check
        curl -f "$STAGING_URL/healthz" || exit 1
        
        # Advanced health check
        HEALTH_RESPONSE=$(curl -s "$STAGING_URL/api/health/" || echo '{}')
        echo "$HEALTH_RESPONSE" | jq '.' || echo "Health check response received"
        
        echo "âœ“ Health checks completed"
    
    - name: Create deployment summary
      run: |
        echo "## ðŸš€ Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status**: âœ… Successfully deployed to staging" >> $GITHUB_STEP_SUMMARY
        echo "**Image**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging\`" >> $GITHUB_STEP_SUMMARY
        echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Verify staging deployment" >> $GITHUB_STEP_SUMMARY
        echo "2. Run manual tests" >> $GITHUB_STEP_SUMMARY
        echo "3. Approve promotion to production when ready" >> $GITHUB_STEP_SUMMARY

  # Promotion gate - manual approval required for production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: always() && needs.deploy-staging.result == 'success' && (startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'))
    environment:
      name: production
      url: ${{ secrets.PRODUCTION_URL || 'https://app.example.com' }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v6
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Tag image for production
      run: |
        # Tag staging image as production
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging || \
        docker pull ${{ needs.build-and-push.outputs.image-tag }}
        
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production || \
        docker tag ${{ needs.build-and-push.outputs.image-tag }} \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production
        
        docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-${{ github.sha }}
        
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-${{ github.sha }}
    
    - name: Run database migrations (production)
      env:
        DATABASE_URL: ${{ secrets.PRODUCTION_DATABASE_URL }}
      run: |
        echo "Running database migrations on production..."
        if [ -z "$DATABASE_URL" ]; then
          echo "âš ï¸ PRODUCTION_DATABASE_URL not set, skipping migrations"
          exit 0
        fi
        
        # Run migrations using the Docker image
        docker run --rm \
          --network host \
          -e DATABASE_URL="$DATABASE_URL" \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production \
          python -m alembic upgrade head || {
            echo "âŒ Production migration failed! Deployment aborted."
            exit 1
          }
        echo "âœ“ Production migrations applied successfully"
    
    - name: Deploy to production
      env:
        PRODUCTION_DEPLOY_METHOD: ${{ secrets.PRODUCTION_DEPLOY_METHOD || 'docker-compose' }}
      run: |
        echo "Deploying to production using $PRODUCTION_DEPLOY_METHOD..."
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production"
        echo ""
        echo "Deployment steps:"
        echo "1. Pull latest image: docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production"
        echo "2. Update docker-compose: docker-compose -f docker-compose.prod.yml pull backend"
        echo "3. Restart services: docker-compose -f docker-compose.prod.yml up -d backend"
        echo ""
        echo "For Kubernetes:"
        echo "kubectl set image deployment/cryptoorchestrator-backend backend=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production -n production"
    
    - name: Wait for production deployment
      env:
        PRODUCTION_URL: ${{ secrets.PRODUCTION_URL || 'http://localhost:8000' }}
      run: |
        echo "Waiting for production deployment to be ready..."
        max_attempts=30
        attempt=0
        
        while [ $attempt -lt $max_attempts ]; do
          if curl -f "$PRODUCTION_URL/healthz" > /dev/null 2>&1; then
            echo "âœ“ Production deployment is healthy"
            exit 0
          fi
          attempt=$((attempt + 1))
          echo "Waiting for health check... ($attempt/$max_attempts)"
          sleep 10
        done
        
        echo "âŒ Production deployment health check failed"
        exit 1
    
    - name: Run production health checks
      env:
        PRODUCTION_URL: ${{ secrets.PRODUCTION_URL || 'http://localhost:8000' }}
      run: |
        echo "Running production health checks..."
        
        if [ -z "$PRODUCTION_URL" ] || [ "$PRODUCTION_URL" == "http://localhost:8000" ]; then
          echo "âš ï¸ PRODUCTION_URL not configured, skipping health checks"
          exit 0
        fi
        
        # Basic health check
        curl -f "$PRODUCTION_URL/healthz" || exit 1
        
        # Advanced health check
        HEALTH_RESPONSE=$(curl -s "$PRODUCTION_URL/api/health/")
        echo "$HEALTH_RESPONSE" | jq '.' || echo "Health check response received"
        
        # Check if all critical components are healthy
        STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.status' || echo "unknown")
        if [ "$STATUS" != "healthy" ] && [ "$STATUS" != "unknown" ]; then
          echo "âŒ Production health check failed: Status is $STATUS"
          exit 1
        fi
        
        echo "âœ“ All production health checks passed"
    
    - name: Create production deployment summary
      run: |
        echo "## ðŸŽ‰ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Status**: âœ… Successfully deployed to production" >> $GITHUB_STEP_SUMMARY
        echo "**Image**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production\`" >> $GITHUB_STEP_SUMMARY
        echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Monitoring" >> $GITHUB_STEP_SUMMARY
        echo "- Production URL: ${{ secrets.PRODUCTION_URL || 'https://app.example.com' }}" >> $GITHUB_STEP_SUMMARY
        echo "- Health Check: ${{ secrets.PRODUCTION_URL || 'https://app.example.com' }}/api/health/" >> $GITHUB_STEP_SUMMARY
