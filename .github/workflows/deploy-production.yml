name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag (e.g., v1.0.0)'
        required: true
        type: string
      skip_tests:
        description: 'Skip tests (not recommended)'
        required: false
        default: false
        type: boolean
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  pre-deployment-checks:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Verify version tag
      run: |
        if [[ ! "${{ github.event.inputs.version }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "❌ Invalid version format. Use vX.Y.Z (e.g., v1.0.0)"
          exit 1
        fi
        echo "✅ Version format valid: ${{ github.event.inputs.version }}"
    
    - name: Check for breaking changes
      run: |
        echo "Checking for breaking changes in migration files..."
        # Add migration compatibility check
    
    - name: Security scan
      uses: github/super-linter@v4
      env:
        DEFAULT_BRANCH: main
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        VALIDATE_PYTHON_BANDIT: true
        VALIDATE_JAVASCRIPT_ES: true

  run-tests:
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'
    needs: pre-deployment-checks
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18.x'
        cache: 'npm'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
        npm ci --legacy-peer-deps
    
    - name: Run all tests
      run: |
        pytest server_fastapi/tests/ -v --cov=server_fastapi --cov-report=xml --cov-fail-under=90
        npm run check
        npm run test:frontend -- --run
      env:
        DATABASE_URL: sqlite:///./test.db
        JWT_SECRET: test-secret-key-for-ci
        TEST_DATABASE_URL: sqlite+aiosqlite:///file:pytest_shared?mode=memory&cache=shared

  build-production:
    needs: [pre-deployment-checks, run-tests]
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract version
      id: version
      run: |
        VERSION="${{ github.event.inputs.version || github.event.release.tag_name || 'latest' }}"
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "Building version: ${VERSION}"
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v4
      with:
        context: .
        file: Dockerfile
        target: production
        push: true
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          VERSION=${{ steps.version.outputs.version }}

  deploy-production:
    needs: build-production
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://api.yourdomain.com
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Extract version
      id: version
      run: |
        VERSION="${{ github.event.inputs.version || github.event.release.tag_name || 'latest' }}"
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
    
    - name: Run database migrations
      run: |
        echo "Running database migrations on production"
        # This would typically run on the production server
        # Example: kubectl exec -it deployment/app -- alembic upgrade head
        # Or: docker-compose exec backend alembic upgrade head
    
    - name: Deploy to production
      run: |
        echo "Deploying version ${{ steps.version.outputs.version }} to production"
        # This would typically use kubectl, docker-compose, or deployment tool
        # Example: kubectl set image deployment/app app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
    
    - name: Wait for deployment
      run: |
        echo "Waiting for deployment to be ready..."
        sleep 60
    
    - name: Health check
      run: |
        echo "Verifying production health..."
        # Health check would verify production is accessible
        # curl -f https://api.yourdomain.com/healthz || exit 1
    
    - name: Run smoke tests
      run: |
        echo "Running smoke tests against production"
        # Run critical path tests against production environment
        # pytest tests/smoke/ -v --base-url=https://api.yourdomain.com

  post-deployment:
    needs: deploy-production
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Verify deployment
      run: |
        echo "✅ Production deployment successful"
        echo "Version: ${{ github.event.inputs.version || github.event.release.tag_name }}"
    
    - name: Create deployment record
      run: |
        echo "Creating deployment record"
        # Record deployment in monitoring system
    
    - name: Notify team
      run: |
        echo "Notifying team of successful deployment"
        # Add notification (Slack, email, PagerDuty, etc.)

  rollback:
    needs: deploy-production
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Rollback deployment
      run: |
        echo "❌ Production deployment failed, initiating rollback"
        # Rollback to previous version
        # Example: kubectl rollout undo deployment/app
    
    - name: Notify team of rollback
      run: |
        echo "Notifying team of rollback"
        # Add notification (Slack, email, PagerDuty, etc.)
