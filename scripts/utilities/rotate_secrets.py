"""
Secret Rotation Script
Generates new secrets for production deployment and updates configuration
"""
import secrets
import string
import os
import sys
from pathlib import Path
from typing import Dict, Optional
import logging
from datetime import datetime

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


def generate_secret_key(length: int = 64) -> str:
    """Generate a secure random secret key"""
    alphabet = string.ascii_letters + string.digits + string.punctuation
    return ''.join(secrets.choice(alphabet) for _ in range(length))


def generate_jwt_secret() -> str:
    """Generate a JWT secret key (32 bytes hex)"""
    return secrets.token_hex(32)


def generate_encryption_key() -> str:
    """Generate a Fernet-compatible encryption key (base64)"""
    from cryptography.fernet import Fernet
    return Fernet.generate_key().decode()


def generate_database_password(length: int = 32) -> str:
    """Generate a secure database password"""
    alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
    return ''.join(secrets.choice(alphabet) for _ in range(length))


def rotate_secrets(
    output_file: Optional[str] = None,
    dry_run: bool = False
) -> Dict[str, str]:
    """
    Generate new secrets for production deployment
    
    Args:
        output_file: Optional file path to write secrets (default: .env.prod.new)
        dry_run: If True, only print secrets without writing to file
    
    Returns:
        Dictionary of new secrets
    """
    secrets_dict = {
        "JWT_SECRET": generate_jwt_secret(),
        "SECRET_KEY": generate_secret_key(),
        "WALLET_ENCRYPTION_KEY": generate_encryption_key(),
        "DATABASE_PASSWORD": generate_database_password(),
        "REDIS_PASSWORD": generate_database_password(24),
        "CELERY_BROKER_PASSWORD": generate_database_password(24),
        "CELERY_RESULT_BACKEND_PASSWORD": generate_database_password(24),
    }
    
    # Add timestamp
    secrets_dict["SECRETS_ROTATED_AT"] = datetime.utcnow().isoformat()
    
    if dry_run:
        logger.info("DRY RUN - Generated secrets (not saved):")
        for key, value in secrets_dict.items():
            logger.info(f"{key}={value[:20]}...")
        return secrets_dict
    
    # Determine output file
    if output_file is None:
        project_root = Path(__file__).resolve().parents[1]
        output_file = project_root / ".env.prod.new"
    
    output_path = Path(output_file)
    
    # Read existing .env.prod if it exists
    existing_secrets = {}
    env_prod_path = output_path.parent / ".env.prod"
    if env_prod_path.exists():
        logger.info(f"Reading existing secrets from {env_prod_path}")
        with open(env_prod_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    existing_secrets[key] = value
    
    # Write new secrets file
    logger.info(f"Writing new secrets to {output_path}")
    with open(output_path, 'w') as f:
        f.write("# Production Secrets - Generated by rotate_secrets.py\n")
        f.write(f"# Generated at: {secrets_dict['SECRETS_ROTATED_AT']}\n")
        f.write("# DO NOT COMMIT THIS FILE TO GIT\n\n")
        
        # Write new secrets
        for key, value in secrets_dict.items():
            if key != "SECRETS_ROTATED_AT":
                f.write(f"{key}={value}\n")
        
        # Preserve other environment variables from existing file
        if existing_secrets:
            f.write("\n# Other environment variables (preserved from .env.prod)\n")
            for key, value in existing_secrets.items():
                if key not in secrets_dict:
                    f.write(f"{key}={value}\n")
    
    logger.info(f"✅ New secrets written to {output_path}")
    logger.info("⚠️  IMPORTANT: Review the new secrets file and update production environment")
    logger.info("⚠️  IMPORTANT: Keep old secrets until migration is complete")
    
    return secrets_dict


def main():
    """Main entry point for secret rotation"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Rotate production secrets")
    parser.add_argument(
        "--output",
        "-o",
        type=str,
        help="Output file path (default: .env.prod.new)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Generate secrets without writing to file",
    )
    
    args = parser.parse_args()
    
    try:
        rotate_secrets(output_file=args.output, dry_run=args.dry_run)
        logger.info("✅ Secret rotation completed successfully")
        return 0
    except Exception as e:
        logger.error(f"❌ Secret rotation failed: {e}", exc_info=True)
        return 1


if __name__ == "__main__":
    sys.exit(main())
